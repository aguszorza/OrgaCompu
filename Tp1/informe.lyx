#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\date{}
\usepackage{float}
\usepackage{units}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{esint}
%\numberwithin{figure}{section}
%\numberwithin{table}{section}
%\numberwithin{equation}{section}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{xcolor}
%-------------------------------------------------------------------------------
%Modificaciones de leyendas en figuras
%\usepackage[footnotesize, labelsep=quad]{caption}
%\captionsetup{width=0.8\textwidth }
\usepackage{caption}
\captionsetup[figure]{margin=40pt,font=normalsize,labelfont=bf}
\captionsetup[table]{margin=40pt,font=normalsize,labelfont=bf} 
%-------------------------------------------------------------------------------
% Added by lyx2lyx
\end_preamble
\use_default_options true
\begin_modules
customHeadersFooters
tcolorbox
fixltx2e
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_author "Agustín Zorzano"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
Organización de Computadoras (66.20)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.5]{fiuba.png}
\backslash

\backslash
[1.5cm]    
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Facultad de Ingeniería - U.B.A.}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large 66.20 Organización de Computadoras - Práctica Martes}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small 2do.
 Cuatrimestre de 2017}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout

 { 
\backslash
Huge 
\backslash
bfseries Trabajo práctico Nº 1}
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge Programación MIPS}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Matias Leandro Feld, Padrón: 99170}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

feldmatias@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Federico Funes, Padrón: 98372}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

fede.funes96@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Agustín Zorzano, Padrón: 99224}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

aguszorza@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

% Bottom of the page {
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Documentación e implementación
\end_layout

\begin_layout Standard

\color black
El objetivo del trabajo es realizar un programa en lenguaje MIPS32 que lea
 palabras de una archivo (o de entrada estándar) y guarde en otro archivo
 (mostrar por salida estándar) únicamente aquellas palabras que sean palíndromos.
 Además, para analizar como influyen en el tiempo de ejecución las lecturas
 y escrituras en archivos, se implementó un sistema de buffer.
\end_layout

\begin_layout Standard
Esto significa que al leer de un archivo no se hará de a un caracter por
 vez, sino que se llenará el buffer de entrada y luego se leerán los caracteres
 desde éste.
\end_layout

\begin_layout Standard
Asimismo, para la escritura de archivos se realizará algo similar.
 Se guardarán en el buffer los caracteres a escribir, y se escribirán en
 el archivo una vez que el buffer se llene.
 De este modo, variando el tamaño del buffer, se podrá analizar como afectan
 al tiempo de ejecución las operaciones con archivos.
\end_layout

\begin_layout Standard

\color black
El programa se divide en las siguientes funciones: 
\end_layout

\begin_layout Enumerate

\color black
La función principal, main, que se encargará de la lógica de leer los parámetros
 de entrada y el manejo de los archivos.
 Si algun archivo no se puede abrir, no se pasaron correctamente los parámetros
 el programa, o se produjo un error en la ejecución, mostrará un mensaje
 de error en el archivo stderr y finalizará con un código de error.
 Esta funcion será escrita en lenguaje C.
\end_layout

\begin_layout Enumerate
Esta función consiste en leer una palabra del archivo de entrada, comprobar
 si es palíndromo y escribirla en el archivo de salida si corresponde.
 Ésta es la función de entrada al programa en MIPS que deberá ser llamada
 desde el programa en C.

\color black
 Recibe por parámetro el archivo de entrada, el de salida y los tamaños
 de los buffer.
 Al ser llamada lo primero que hará es crear los buffer de entrada y salida,
 utilizando la función crear_buffer().
 Luego entrará en el bucle hasta que todos los caracteres del archivo de
 entrada sean analizados.
 El bucle termina cuando se lee el EOF, y en este caso se llamará una vez
 más a la función que escribe en archivos para escribir todo lo que haya
 quedado en el buffer de salida.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de leer_archivo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\color black
La función leer_palabra, que se encarga de leer una palabra del archivo.
 Debido a las limitaciones de lo que se considera palabra, y a que no hay
 limitación con respecto a cantidad de letras de una palabra, lo que hacemos
 es leer carácter por carácter, guardándolos en un vector alojado en memoria
 dinámica que se irá redimensionando a medida que sea necesario.
 Para ello, definimos una variable TAM que determinará la cantidad de memoria
 que se pide al inicio y al redimensionar.
 En principio esa variable puede contener cualquier número, pero para no
 estar redimensionando muchas veces y para no pedir mucha memoria innecesaria,
 definimos ese valor en 30.
 La función recibe por parámetro un puntero a entero, que sirve para guardar
 la longitud de la palabra leída, con el objetivo de no tener que calcularla
 nuevamente en otro momento.
 Para leer un caracter del archivo llamará a la función getch().
 Para facilitar la escritura de la palabra en el archivo de salida, al final
 de cada palabra se insertará un 
\backslash
n en lugar de un 
\backslash
0, ya que 
\backslash
n no es considerado un caracter, y además necesitamos imprimirlo luego de
 cada palabra.
 El stackframe correspondiente a la función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_palabra.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de leer_palabra
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\color black
La función es_capicúa, que se encarga de comprobar si la palabra es o no
 un palíndromo, y devuelve un valor booleano según corresponda.
 Ésta función recibe por parámetro el puntero a la palabra y la longitud
 de la misma.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_es_capicua.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de es_capicua
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función my_tolower, que fue implementada para reemplazar la del lenguaje
 C, se encarga de pasar a minúscula un caracter.
 Para eso, recibe por parámetro el caracter, y lo transforma únicamente
 si es una letra mayúscula, caso contrario lo devuelve como viene.

\color black
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_my_tolower.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de my_tolower
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función crear_buffer, es la encargada de crear los buffers.
 Para ello recibirá por parámetro el tamaño del mismo, y lo creará haciendo
 uso de la función mymalloc.
 Como resultado devuelve el puntero al buffer correspondiente.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_crear_buffer.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de crear_buffer
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función getch, que se encarga de leer un carácter del archivo de entrada.
 Como se explicó anteriormente, ésta hace uso de un buffer.
 Por lo tanto, conociendo el tamaño del buffer y la última posición leída,
 devolverá el caracter correspondiente, y cuando la posición sea mayor o
 igual al tamaño se encargará de llenar el buffer nuevamente con nuevos
 datos.
 Esta función tiene una complicación adicional, ya que debe indicar cuando
 fue leído el final del archivo en el buffer.
 Para eso, utilizaremos una variable global, que será nula hasta el momento
 en que se lee el EOF, que cambiará de valor y permitirá avisar a las demás
 funciones que ya se leyó todo el archivo.
 Si se produjera algún error en la lectura devolverá un código de error.
 Para la lectura del archivo hace uso de un syscall, puede ocurrir que se
 lean menos bytes de los pedidos, en ese caso pueden ser por dos razones,
 que no hay más por leer o que se leyó menos pero se puede leer más.
 Esto lo solucionamos haciendo que la lectura se haga en un loop, que termina
 cuando no hay más para leer o cuando se llenó el buffer.
 Cuando se lee el EOF, para poder distinguir si quedan o no caracteres en
 el buffer para analizar, lo que hacemos es realizar una doble llamada al
 syscall.
 En la primera, se determina si quedan o no caracteres para analizar, si
 devuelve cero significa que no hay más.
 En cambio, si la segunda llamada, que es la que se realiza en el loop,
 devuelve cero en algún ciclo del loop, significa que se alcanzó el final
 de archivo pero todavía hay caracteres para analizar en el buffer.
 En este último caso no se actualiza la variable global que indica que el
 EOF fue leído.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_caracter_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de getch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función putch, que se encarga de escribir una palabra en el archivo de
 salida.
 Debido a que debe utilizar el buffer, la función recibirá por parámetro
 la palabra, y guardará de a un caracter por vez en el buffer.
 Una vez que se llene el buffer, independientemente si se guardó toda la
 palabra o no, éste se escribirá en el archivo y se vaciará.
 Al igual que la anterior, también tiene una complicación.
 Puede ocurrir que el buffer no se llene completamente y se haya terminado
 el archivo, en cuyo caso, utilizando la variable global que indica si se
 debe escribir el EOF, escribirá todo lo que se encuentre en el buffer en
 ese momento.
 También, puede ocurrir que el syscall no escriba el total de los bytes
 pedidos, por lo que la escritura se realiza en un loop hasta que escriba
 todo.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera
\color black
:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_escribir_palabra_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de putch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Por último, la función myrealloc, que sirve para redimensionar un bloque
 de memoria dinámica.
 Para facilitar la programación de la misma, y porque no lo necesitamos,
 se decidió que solo se podrá redimensionar aumentando el tamaño del bloque
 y no disminuyéndolo.
 Por eso, la función recibe por parámetro el puntero al bloque, el tamaño
 actual, y el tamaño a agregar.
 Haciendo uso de la función mymalloc crea un nuevo bloque y copia byte por
 byte los datos del bloque viejo al nuevo.
 Finalmente libera el bloque viejo y devuelve el nuevo.
 Si se produjera un error al llamar a la función mymalloc se devolverá un
 puntero a NULL.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_myrealloc.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de myrealloc
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Variables globales
\end_layout

\begin_layout Standard
A continuación se explican las variables globales utilizadas y cómo se las
 interpreta.
\end_layout

\begin_layout Enumerate
pos_buffer_entrada: Indica la posición del próximo caracter a leer en el
 buffer de entrada.
 Se incrementa en uno cada vez que se lee un caracter y se reinicia a cero
 cuando se vuelve a llenar el buffer.
 Esta variable comienza seteada en -1, que sin signo es el número más alto,
 para que se produzca la primer lectura del archivo.
\end_layout

\begin_layout Enumerate
pos_buffer_salida: Indica la posición del próximo caracter a escribir en
 el buffer de salida.
 Se incrementa en uno cada vez que se escribe un caracter y se reinicia
 a cero cuando se realiza la escritura del archivo y se vacía el buffer.
\end_layout

\begin_layout Enumerate
tam_buffer_entrada: Indica el tamaño del buffer de entrada.
 Se inicializa en la creación del buffer con su valor correspondiente.
 Solo se actualiza cuando se realiza la última lectura (que lee menos bytes)
 para saber cuántos bytes quedan.
\end_layout

\begin_layout Enumerate
tam_buffer_salida: Indica el tamaño del buffer de salida.
 Se inicializa en la creación del buffer con su valor correspondiente.
 Solo se actualiza cuando se debe realizar la última escritura (que escribe
 menos bytes) para saber cuántos bytes quedan en el buffer.
\end_layout

\begin_layout Enumerate
eof_leido: Permite saber cuando se alcanzó el final del archivo de lectura.
 Su valor es 0 hasta el momento que se hayan leído todos los caracteres
 del archivo de entrada y además el buffer de entrada esté vacío, es decir,
 que ya se analizaron todos los caracteres.
 Permite saber que debemos escribir todo lo que queda en el buffer de salida
 y terminar el programa.
\end_layout

\begin_layout Enumerate
TAM: Es el tamaño del bloque de memoria que se crea para cada palabra, y
 también el tamaño a agregarle al redimensionar.
\end_layout

\begin_layout Section
Comandos para compilacion
\end_layout

\begin_layout Standard
Para compilar el programa utilizamos el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ gcc -Wall -o tp1 main.c mymalloc.S myrealloc.S palindrome.S getch.S putch.S
 crear_buffer.S leer_palabra.S es_capicua.S my_tolower.S
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
o se puede optar por ejecutar el script de bash:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ bash compilar.sh
\end_layout

\begin_layout Section
Pruebas
\end_layout

\begin_layout Standard
Para probar el programa utilizamos un script de bash llamado 'pruebas.sh'
 que contiene un conjunto de pruebas que se realizan automáticamente.
 Entre ellas,se encuentran pruebas con archivos vacios, archivos con un
 solo caracter y archivos solo con simbolos.
 Por otro lado, también se prueba que funcionen correctamente los mensajes
 de error cuando los parámetros no son usados correctamente.
 Se realizan pruebas para distintos tamaños de buffer para asegurarnos que
 funcione correctamente.
 Todas las pruebas utilizan el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ diff salida.txt resultado.txt
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde si no muestra nada significa que ambos archivos son iguales, y que
 por lo tanto todas las pruebas del programa funcionan correctamente.
\end_layout

\begin_layout Standard
En algunas de las pruebas utilizamos un archivo de texto ''entrada.txt''
 que contiene un conjunto de palabras con combinaciones de letras, numeros
 y guiones y mezclando mayúsculas y minúsculas.
 Luego tenemos otro archivo, ''resultado.txt'' que es lo que se espera que
 devuelva el programa al ejecutarse con ese archivo de entrada.
 En la siguiente sección se muestran esos archivos.
 Por otro lado, también se realizan pruebas con un archivo ''archivo_largo.txt'',
 que contiene 30 líneas de 5000 caracteres cada una, y donde además todas
 son palindromos.
 En el resto de las pruebas se usan archivos creados dentro del mismo script,
 que se borran al finalizar.
\end_layout

\begin_layout Standard
También realizamos pruebas utilizando salida estándar y entrada estándar,
 los cuales funcionaron correctamente.
 Cuando se trabaja con entrada estándar y se desea finalizar se debe ingresar
 ''ctrl D'', que inserta un EOF, ya que utilizando ''ctrl C'' finaliza abruptame
 nte y no se guarda correctamente el resultado.
\end_layout

\begin_layout Standard
El script de pruebas se puede ejecutar con el comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ bash pruebas.sh
\end_layout

\begin_layout Subsection
Archivo 'pruebas.sh'
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#/bin/bash
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bash compilar.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con archivo de pruebas entrada.txt y resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba con archivo vacio
\end_layout

\begin_layout Plain Layout

touch vacio.txt
\end_layout

\begin_layout Plain Layout

touch resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i vacio.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con una sola letra mayúscula
\end_layout

\begin_layout Plain Layout

echo M > res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo M | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con una sola letra minúscula
\end_layout

\begin_layout Plain Layout

echo m > res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo m | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba con un número
\end_layout

\begin_layout Plain Layout

echo 3 > res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo 3 | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con un guion
\end_layout

\begin_layout Plain Layout

echo - > res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo - | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con un guion bajo
\end_layout

\begin_layout Plain Layout

echo _ > res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

echo _ | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con un simbolo
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

echo @ | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba con espacios
\end_layout

\begin_layout Plain Layout

echo "                    " > ent.txt 
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Pruebas con simbolos
\end_layout

\begin_layout Plain Layout

echo "@#$%^*()!{}[],./?<>;:*+
\backslash
|=+" > ent.txt 
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i ent.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Prueba con un archivo con 30 lineas de 5000 caracteres cada una,
\end_layout

\begin_layout Plain Layout

# donde cada una es palindromo en su totalidad
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i archivo_largo.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout

diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: no se ingresa archivo de entrada
\end_layout

\begin_layout Plain Layout

echo "Debe indicar un archivo de entrada luego de -i" > res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -i 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -O 10 -i 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -i 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: no se ingresa archivo de salida
\end_layout

\begin_layout Plain Layout

echo "Debe indicar un archivo de salida luego de -o" > res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -o 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -o 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -O 10 -o 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: no se ingresa tamaño del buffer de entrada
\end_layout

\begin_layout Plain Layout

echo "Debe indicar un numero luego de -I" > res.txt       
\end_layout

\begin_layout Plain Layout

./tp1 -I 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -O 10 -I 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -O 10 -I 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: no se ingresa tamaño del buffer de salida
\end_layout

\begin_layout Plain Layout

echo "Debe indicar un numero luego de -O" > res.txt     
\end_layout

\begin_layout Plain Layout

./tp1 -O 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -O 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -O 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 10 -O 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: no se puede abrir el archivo de entrada
\end_layout

\begin_layout Plain Layout

echo "El archivo de entrada no pudo abrirse" > res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i inexistente.txt -I 10 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: el tamaño del buffer de entrada no es un numero
\end_layout

\begin_layout Plain Layout

echo "El parametro de -I debe ser un numero" > res.txt			
\end_layout

\begin_layout Plain Layout

./tp1 -I abc 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I numero 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -O 10 -I nueve 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -O 10 -I abc123 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Prueba error: el tamaño del buffer de salida no es un numero
\end_layout

\begin_layout Plain Layout

echo "El parametro de -O debe ser un numero" > res.txt			
\end_layout

\begin_layout Plain Layout

./tp1 -O abc 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -O numero 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -I 10 -O nueve 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 10 -O abc123 2> error.txt
\end_layout

\begin_layout Plain Layout

diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Pruebas con stdin (sin poner '-i' o poniendo '-i -')
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 1 -O 1  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 20 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 100 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 1000 -O 1000  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 20 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -o salida.txt -I 100 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i - -o salida.txt -I 1 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i - -o salida.txt -I 100 -O 1  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i - -o salida.txt -I 20 -O 1000  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i - -o salida.txt -I 1000 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Prueba con stdout (sin poner '-o' o poniendo '-o -')
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 1 -O 1 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 20 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 100 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 1000 -O 1000 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 20 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 100 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 1 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 100 -O 1 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 20 -O 1000 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

./tp1 -i entrada.txt -I 1000 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout

diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Borramos archivos sobrantes
\end_layout

\begin_layout Plain Layout

rm vacio.txt
\end_layout

\begin_layout Plain Layout

rm resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

rm salida.txt
\end_layout

\begin_layout Plain Layout

rm ent.txt
\end_layout

\begin_layout Plain Layout

rm error.txt
\end_layout

\begin_layout Plain Layout

rm res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ’entrada.txt’
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

Pruebas varias:
\end_layout

\begin_layout Plain Layout

aaa     pelota hola como estas
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pepep aaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

_aa_
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

_aAAa_
\end_layout

\begin_layout Plain Layout

-a-a-
\end_layout

\begin_layout Plain Layout

-a-a
\end_layout

\begin_layout Plain Layout

Neuquen
\end_layout

\begin_layout Plain Layout

-Neuquen-   neu%q%uen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1234321   ?123?123abc4cba321
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Prueba del enunciado:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Somos los primeros en completar el TP 0.
\end_layout

\begin_layout Plain Layout

Ojo que La fecha de entrega del TP0 es el martes 12 de septiembre.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Palabras largas mezcladas:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abcdefghijklmnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba??=
=
\end_layout

\begin_layout Plain Layout

ABCDEFGHIJKLMnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba??=
=
\end_layout

\begin_layout Plain Layout

EstoesUnPalindromoOMOrdnilapNUSEOTse.........EStono
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas de guiones  guiones bajos:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

__--__???????######$$$$_-_-_@@@@@-_-__-_-!    ---___
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas de palabras de una letra:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a   %%% % 1 2 ^4^ - _ C D
\end_layout

\begin_layout Plain Layout

b  ! @ # $ % ^ & * ( ) = + 
\backslash

\end_layout

\begin_layout Plain Layout

c
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas solo mayusculas:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AAA ABCDEDCBA   ABC123--321CBA  WXXW
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PALINDROMO  -ABCB-
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ’resultado.txt’
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

aaa
\end_layout

\begin_layout Plain Layout

pepep
\end_layout

\begin_layout Plain Layout

aaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

aaaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

_aa_
\end_layout

\begin_layout Plain Layout

_aAAa_
\end_layout

\begin_layout Plain Layout

-a-a-
\end_layout

\begin_layout Plain Layout

Neuquen
\end_layout

\begin_layout Plain Layout

-Neuquen-
\end_layout

\begin_layout Plain Layout

q
\end_layout

\begin_layout Plain Layout

1234321
\end_layout

\begin_layout Plain Layout

123abc4cba321
\end_layout

\begin_layout Plain Layout

Somos
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

Ojo
\end_layout

\begin_layout Plain Layout

abcdefghijklmnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba
\end_layout

\begin_layout Plain Layout

ABCDEFGHIJKLMnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba
\end_layout

\begin_layout Plain Layout

EstoesUnPalindromoOMOrdnilapNUSEOTse
\end_layout

\begin_layout Plain Layout

__--__
\end_layout

\begin_layout Plain Layout

_-_-_
\end_layout

\begin_layout Plain Layout

-_-__-_-
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

-
\end_layout

\begin_layout Plain Layout

_
\end_layout

\begin_layout Plain Layout

C
\end_layout

\begin_layout Plain Layout

D
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

c
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

AAA
\end_layout

\begin_layout Plain Layout

ABCDEDCBA
\end_layout

\begin_layout Plain Layout

ABC123--321CBA
\end_layout

\begin_layout Plain Layout

WXXW
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo archivo_largo.txt
\end_layout

\begin_layout Standard
La función de este archivo es trabajar con varios palíndromos largos para
 así poder probar el programa corerctamente.
 A continuación se muestra la primer línea de este archivo.
 Las lineas faltantes son una copia de ésta.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "documento hijo/hijo.lyx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Section
Mediciones del tiempo de ejecución
\end_layout

\begin_layout Standard
Como se mencionó anteriormente, el objetivo del uso de los buffers es medir
 cómo afectan las operaciones con archivos al tiempo de ejecución.
 Para eso, creamos un script 'time.sh', que mide el tiempo que tarda en ejecutars
 e el programa con distintos tamaños de buffer, y guarda el resultado en
 un archivo 'time.txt'.
 Se realizaron las mismas mediciones con el archivo 'entrada.txt' (3.2) y
 con el 'archivo_largo.txt' (3.4), para analizar cómo afecta también el tamaño
 del archivo.
\end_layout

\begin_layout Standard
El script de mediciones se puede ejecutar con el comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ bash time.sh
\end_layout

\begin_layout Subsection
Archivo ''time.sh''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#/bin/bash
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bash compilar.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Crea el archivo vacio
\end_layout

\begin_layout Plain Layout

cat /dev/null > time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "MEDICIONES CON ARCHIVO DE PRUEBAS ENTRADA.TXT
\backslash
n" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "Resultado con 1 byte de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 1 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 20 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 20 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 50 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 50 -O 50)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 100 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 100 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 250 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 250 -O 250)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 500 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 500 -O 500)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 1000 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i entrada.txt -o salida.txt -I 1000 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
n
\backslash
nMEDICIONES CON ARCHIVO CON 30 LINEAS DE 5000 CARACTERES CADA UNA (TODAS
 SON PALINDROMO)
\backslash
n" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 1 byte de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 20 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 50 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 50 -O 50)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 100 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 250 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 250 -O 250)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 500 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 500 -O 500)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

echo -e "
\backslash
nResultado con 1000 bytes de buffer:" >> time.txt
\end_layout

\begin_layout Plain Layout

(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1000 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rm salida.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''time.txt''
\end_layout

\begin_layout Standard
Este es el resultado obtenido al ejecutar las mediciones:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

MEDICIONES CON ARCHIVO DE PRUEBAS ENTRADA.TXT
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 1 byte de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.066s
\end_layout

\begin_layout Plain Layout

user	0m0.000s
\end_layout

\begin_layout Plain Layout

sys	0m0.082s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 20 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.035s
\end_layout

\begin_layout Plain Layout

user	0m0.022s
\end_layout

\begin_layout Plain Layout

sys	0m0.017s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 50 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.035s
\end_layout

\begin_layout Plain Layout

user	0m0.023s
\end_layout

\begin_layout Plain Layout

sys	0m0.028s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 100 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.031s
\end_layout

\begin_layout Plain Layout

user	0m0.000s
\end_layout

\begin_layout Plain Layout

sys	0m0.043s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 250 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.035s
\end_layout

\begin_layout Plain Layout

user	0m0.004s
\end_layout

\begin_layout Plain Layout

sys	0m0.031s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 500 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.035s
\end_layout

\begin_layout Plain Layout

user	0m0.028s
\end_layout

\begin_layout Plain Layout

sys	0m0.023s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 1000 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m0.031s
\end_layout

\begin_layout Plain Layout

user	0m0.004s
\end_layout

\begin_layout Plain Layout

sys	0m0.027s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MEDICIONES CON ARCHIVO CON 30 LINEAS DE 5000 CARACTERES CADA UNA (TODAS
 SON PALINDROMO)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 1 byte de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m10.133s
\end_layout

\begin_layout Plain Layout

user	0m1.816s
\end_layout

\begin_layout Plain Layout

sys	0m8.336s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 20 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.750s
\end_layout

\begin_layout Plain Layout

user	0m1.125s
\end_layout

\begin_layout Plain Layout

sys	0m0.625s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 50 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.500s
\end_layout

\begin_layout Plain Layout

user	0m1.160s
\end_layout

\begin_layout Plain Layout

sys	0m0.355s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 100 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.402s
\end_layout

\begin_layout Plain Layout

user	0m1.094s
\end_layout

\begin_layout Plain Layout

sys	0m0.320s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 250 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.383s
\end_layout

\begin_layout Plain Layout

user	0m1.082s
\end_layout

\begin_layout Plain Layout

sys	0m0.316s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 500 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.336s
\end_layout

\begin_layout Plain Layout

user	0m1.035s
\end_layout

\begin_layout Plain Layout

sys	0m0.316s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Resultado con 1000 bytes de buffer:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

real	0m1.332s
\end_layout

\begin_layout Plain Layout

user	0m1.019s
\end_layout

\begin_layout Plain Layout

sys	0m0.317s
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Resultados y comparaciones
\end_layout

\begin_layout Standard
Para analizar los resultados, realizamos unos gráficos con los datos obtenidos:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename tiempos_corto.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tiempos de ejecución para archivos cortos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename tiempos_largo.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tiempos de ejecución para archivos largos
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como se puede observar en ambos gráficos, la mayor diferencia se encuentra
 entre el buffer de tamaño 1 byte y el de 20 bytes, es decir, cuando el
 buffer es muy chico.
 Se puede ver que si se sigue aumentando el tamaño el tiempo casi no cambia.
 Por otro lado, es importante notar que para el archivo largo la diferencia
 entre el tamaño 1 byte y el de 20 bytes es muy grande, aproximadamente
 10 segundos.
 Esto significa que cuanto más grande es el archivo, mayor es la importancia
 de que el buffer no sea muy pequeño, aunque tampoco hace falta que sea
 muy grande.
 Con los resultados obtenidos, podemos afirmar que el tamaño óptimo del
 buffer está entre 15 y 100 bytes.
\end_layout

\begin_layout Section
Código fuente
\end_layout

\begin_layout Subsection
Archivo ''main.c''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extern int palindrome (int ifd, size_t ibytes, int ofd, size_t obytes);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char* argv[]){
\end_layout

\begin_layout Plain Layout

	FILE* entrada = stdin;
\end_layout

\begin_layout Plain Layout

	FILE* salida = stdout;
\end_layout

\begin_layout Plain Layout

	int tam_buffer_entrada = 1;
\end_layout

\begin_layout Plain Layout

	int tam_buffer_salida = 1;
\end_layout

\begin_layout Plain Layout

	char* parametro;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	int i;
\end_layout

\begin_layout Plain Layout

	for (i = 1; i < argc; i += 2){
\end_layout

\begin_layout Plain Layout

		if ((strcmp(argv[i],"-i") == 0) || (strcmp(argv[i],"--input") == 0)){
\end_layout

\begin_layout Plain Layout

			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout

				fputs("Debe indicar un archivo de entrada luego de -i
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

				return 3;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout

			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout

				entrada = fopen(argv[i + 1], "r");
\end_layout

\begin_layout Plain Layout

				if (!entrada){
\end_layout

\begin_layout Plain Layout

					fputs("El archivo de entrada no pudo abrirse
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

					return 4;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((strcmp(argv[i],"-o") == 0) || (strcmp(argv[i],"--output") ==
 0)){
\end_layout

\begin_layout Plain Layout

			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout

				fputs("Debe indicar un archivo de salida luego de -o
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

				return 3;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout

			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout

				salida = fopen(argv[i + 1], "w");
\end_layout

\begin_layout Plain Layout

				if (!salida){
\end_layout

\begin_layout Plain Layout

					fputs("El archivo de salida no pudo abrirse
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

					return 4;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((strcmp(argv[i],"-I") == 0) || (strcmp(argv[i],"--ibuff-bytes")
 == 0)){
\end_layout

\begin_layout Plain Layout

			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout

				fputs("Debe indicar un numero luego de -I
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

				return 3;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout

			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout

				tam_buffer_entrada = atoi(parametro);
\end_layout

\begin_layout Plain Layout

				if (tam_buffer_entrada == 0){
\end_layout

\begin_layout Plain Layout

					fputs("El parametro de -I debe ser un numero
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

					return 4;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((strcmp(argv[i],"-O") == 0) || (strcmp(argv[i],"--obuff-bytes")
 == 0)){
\end_layout

\begin_layout Plain Layout

			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout

				fputs("Debe indicar un numero luego de -O
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

				return 3;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout

			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout

				tam_buffer_salida = atoi(parametro);
\end_layout

\begin_layout Plain Layout

				if (tam_buffer_salida == 0){
\end_layout

\begin_layout Plain Layout

					fputs("El parametro de -O debe ser un numero
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

					return 4;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((strcmp(argv[i],"-V") == 0) || (strcmp(argv[i],"--version") ==
 0)){
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "TP1 version 1.0001
\backslash
n");
\end_layout

\begin_layout Plain Layout

			return 0;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((strcmp(argv[i],"-h") == 0) || (strcmp(argv[i],"--help") == 0)){
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "Usage:
\backslash
n
\backslash
ntp1 -h
\backslash
ntp1 -V
\backslash
ntp1 [options]
\backslash
n
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "Options:
\backslash
n-V, --version  Print version and quit.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "-h, --help   Print this information.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "-i, --input   Location of the input file.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "-o, --output   Location of the output file.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "-I, --ibuf-bytes Byte-count of the input buffer.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "-O, --obuf-bytes Byte-count of the output buffer.
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fprintf(stdout, "
\backslash
nExample:
\backslash
ntp1 -i ~/input -o ~/output -I 10 -O 10
\backslash
n
\backslash
n");
\end_layout

\begin_layout Plain Layout

			return 0;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else {
\end_layout

\begin_layout Plain Layout

			fputs("La opcion seleccionada no existe, ejecute la opcion -h para mas
 informacion.
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

			return 3;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	int resultado = palindrome(fileno(entrada), tam_buffer_entrada, fileno(salida),
 tam_buffer_salida);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (resultado != 0){
\end_layout

\begin_layout Plain Layout

		fputs("Ocurrio un error
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	fclose(entrada);
\end_layout

\begin_layout Plain Layout

	fclose(salida);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return resultado;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''palindrome.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout
#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout
#define TAM_SF 48
\end_layout

\begin_layout Plain Layout
#define FP_SF 32
\end_layout

\begin_layout Plain Layout
#define GP_SF 36
\end_layout

\begin_layout Plain Layout
#define RA_SF 40
\end_layout

\begin_layout Plain Layout
#define ARG0 48
\end_layout

\begin_layout Plain Layout
#define ARG1 52
\end_layout

\begin_layout Plain Layout
#define ARG2 56
\end_layout

\begin_layout Plain Layout
#define ARG3 60
\end_layout

\begin_layout Plain Layout
#define BUFF_IN 24
\end_layout

\begin_layout Plain Layout
#define BUFF_OUT 28
\end_layout

\begin_layout Plain Layout
#define LEN 16
\end_layout

\begin_layout Plain Layout
#define POINTER 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.text
\end_layout

\begin_layout Plain Layout
.abicalls
\end_layout

\begin_layout Plain Layout
.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.globl palindrome
\end_layout

\begin_layout Plain Layout
.ent palindrome
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
palindrome:							
\end_layout

\begin_layout Plain Layout
	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout
	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout
	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, ARG0($fp)                #guardamos el archivo de entrada
\end_layout

\begin_layout Plain Layout
	sw a1, ARG1($fp)                #guardamos el tamanio buffer entrada
\end_layout

\begin_layout Plain Layout
    sw a2, ARG2($fp)                #guardamos el archivo de salida
\end_layout

\begin_layout Plain Layout
    sw a3, ARG3($fp)                #guardamos el tamanio buffer salida
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    move a0, a1                     #a0 = tamanio del buffer entrada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    la t9, crear_buffer
\end_layout

\begin_layout Plain Layout
    jalr t9                           	#Crea el buffer de entrada
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_primer_buffer	#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout
    sw v0, BUFF_IN($fp)                 #Guardamos el buffer de entrada
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw t1, ARG1($fp)
\end_layout

\begin_layout Plain Layout
    sw t1, 0(t0)				    #Actualiza el tam del buffer entrada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    lw a0, ARG3($fp)                    #a0 = tam del buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, crear_buffer
\end_layout

\begin_layout Plain Layout
    jalr t9                           	#Crea el buffer de salida
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_segundo_buffer	#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout
    sw v0, BUFF_OUT($fp)                #Guardamos el buffer de salida
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw t1, ARG3($fp)
\end_layout

\begin_layout Plain Layout
    sw t1, 0(t0)				     #Actualiza el tam del buffer salida
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
loop:
\end_layout

\begin_layout Plain Layout
    lw a0, ARG0($fp)                    #a0 = archivo de entrada
\end_layout

\begin_layout Plain Layout
	addu a1, $fp, LEN                   #a1 = puntero a len
\end_layout

\begin_layout Plain Layout
    lw a2, BUFF_IN($fp)                 #a2 = buffer de entrada
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	la t9, leer_palabra
\end_layout

\begin_layout Plain Layout
	jalr t9                          	#Lee la proxima palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sw v0, POINTER($fp)               #Guardamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout
	beq v0, zero, error             #Salta si no se pudo leer la palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	move a0, v0                        #a0 = puntero a palabra
\end_layout

\begin_layout Plain Layout
    lw a1, LEN ($fp)                   #a1 = len(palabra)
\end_layout

\begin_layout Plain Layout
	la t9, es_capicua
\end_layout

\begin_layout Plain Layout
	jalr t9                            #Llama a es_capicua      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	beq v0, zero, continuar_loop       #Si no es capicua sigue el loop    
     
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw a0, ARG2($fp)                   #a0 = archivo de salida
\end_layout

\begin_layout Plain Layout
	lw a1, POINTER($fp)                #a1 = puntero a la palabra
\end_layout

\begin_layout Plain Layout
    lw a2, BUFF_OUT($fp)               #a2 = buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, putch
\end_layout

\begin_layout Plain Layout
    jalr t9                            #Escribe la palabra en el archivo
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_escritura	   #Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
continuar_loop:
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    lw a0, POINTER($fp)                #a0 = puntero a palabra
\end_layout

\begin_layout Plain Layout
    la t9, myfree
\end_layout

\begin_layout Plain Layout
    jalr t9                            #Llama a free(palabra)
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, eof_leido
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)					   #t1 = eof leido?
\end_layout

\begin_layout Plain Layout
    beq t1, zero, loop           	   #si no fue leido sigue el loop
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    lw a0, ARG2($fp)				   #a0 = archivo de salida
\end_layout

\begin_layout Plain Layout
    lw a2, BUFF_OUT($fp)			   #a2 = buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, putch
\end_layout

\begin_layout Plain Layout
    jalr t9                      #Escribe todo lo que queda en el buffer
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error         	   #Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
terminar:
\end_layout

\begin_layout Plain Layout
	move v0, zero
\end_layout

\begin_layout Plain Layout
free_segundo_buffer:
\end_layout

\begin_layout Plain Layout
	lw a0, BUFF_OUT($fp)                #Cargamos el buffer de salida 
\end_layout

\begin_layout Plain Layout
	la t9,myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Liberamos el segundo buffer
\end_layout

\begin_layout Plain Layout
free_primer_buffer:
\end_layout

\begin_layout Plain Layout
	lw a0, BUFF_IN($fp)                 #Cargamos el buffer de entrada 
\end_layout

\begin_layout Plain Layout
	la t9,myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Liberamos el primer buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return:
\end_layout

\begin_layout Plain Layout
	lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_segundo_buffer:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1					#Devuelve codigo de error 1
\end_layout

\begin_layout Plain Layout
	b free_primer_buffer				#Libera el primer buffer
\end_layout

\begin_layout Plain Layout
error_primer_buffer:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1 					#Devuelve codigo de error 1
\end_layout

\begin_layout Plain Layout
	b return        					#No libera nada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_escritura:
\end_layout

\begin_layout Plain Layout
	lw a0, POINTER($fp)                 #a0 = puntero a la palabra
\end_layout

\begin_layout Plain Layout
	la t9, myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Libera la palabra
\end_layout

\begin_layout Plain Layout
error:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 2 					#Devuelve codigo de error 2
\end_layout

\begin_layout Plain Layout
	b free_segundo_buffer				#Libera ambos buffer
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
.end palindrome
\end_layout

\begin_layout Plain Layout
.size palindrome,.-palindrome
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.globl pos_buffer_entrada
\end_layout

\begin_layout Plain Layout
.globl tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
.globl pos_buffer_salida
\end_layout

\begin_layout Plain Layout
.globl tam_buffer_salida
\end_layout

\begin_layout Plain Layout
.globl eof_leido
\end_layout

\begin_layout Plain Layout
.globl TAM
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
pos_buffer_entrada: .word -1
\end_layout

\begin_layout Plain Layout
tam_buffer_entrada: .word 0
\end_layout

\begin_layout Plain Layout
pos_buffer_salida: .word 0
\end_layout

\begin_layout Plain Layout
tam_buffer_salida: .word 0
\end_layout

\begin_layout Plain Layout
eof_leido: .word 0
\end_layout

\begin_layout Plain Layout
TAM: .word 30
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''getch.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#include <sys/syscall.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 40
\end_layout

\begin_layout Plain Layout

#define S0_SF 16
\end_layout

\begin_layout Plain Layout

#define S1_SF 20
\end_layout

\begin_layout Plain Layout

#define FP_SF 24
\end_layout

\begin_layout Plain Layout

#define GP_SF 28
\end_layout

\begin_layout Plain Layout

#define RA_SF 32
\end_layout

\begin_layout Plain Layout

#define ARG0 40
\end_layout

\begin_layout Plain Layout

#define ARG1 44
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl getch
\end_layout

\begin_layout Plain Layout

.ent getch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

getch:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	sw s0, S0_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw s1, S1_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)                  #Guardamos el archivo de entrada
\end_layout

\begin_layout Plain Layout

	sw a1, ARG1($fp)                  #Guardamos el puntero al buffer
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    la t0, pos_buffer_entrada
\end_layout

\begin_layout Plain Layout

    lw s0, 0(t0)                      #s0 = pos actual del buffer
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout

    lw a2, 0(t0)                      #a2 = tam actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    bltu s0, a2, leer_caracter        #Salta si pos actual < tam buffer
       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Si no salta hay que volver a leer del archivo y llenar el buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    li v0, SYS_read					  #a0,a1,a2 ya estan seteados
\end_layout

\begin_layout Plain Layout

    syscall
\end_layout

\begin_layout Plain Layout

    bne a3, zero, error			      #Salta si hubo un error
\end_layout

\begin_layout Plain Layout

    beq v0, zero, leyo_eof		      #Si read devuelve 0 leyo EOF
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    addu s0, zero, zero               #Pos_actual = 0
\end_layout

\begin_layout Plain Layout

    move s1,v0 						  #s1 = cantidad bytes leidos
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout

    lw a2, 0(t0)                      #a2 = tam actual del buffer
\end_layout

\begin_layout Plain Layout

    beq v0,a2, leer_caracter		  #Salta si read no leyo menos bytes 
\end_layout

\begin_layout Plain Layout

									  #de lo indicado
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

#Si leyo menos bytes 
\end_layout

\begin_layout Plain Layout

leer_archivo:
\end_layout

\begin_layout Plain Layout

	lw a0, ARG0($fp)                  # a0 = archivo de entrada
\end_layout

\begin_layout Plain Layout

	lw a1, ARG1($fp)                      
\end_layout

\begin_layout Plain Layout

	addu a1, a1, s1				 #a1=puntero buffer + cant bytes leidos
\end_layout

\begin_layout Plain Layout

	la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout

    lw a2, 0(t0)                      
\end_layout

\begin_layout Plain Layout

	subu a2, a2, s1					  #a2=tam buffer - cant bytes leidos
\end_layout

\begin_layout Plain Layout

	li v0, SYS_read
\end_layout

\begin_layout Plain Layout

	syscall
\end_layout

\begin_layout Plain Layout

	bne a3, zero, error			        #Salta si hubo un error
\end_layout

\begin_layout Plain Layout

	beq v0, zero, eof_fue_leido      	#Si es cero leyo eof
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	addu s1, s1, v0						#s1 = cant bytes leidos
\end_layout

\begin_layout Plain Layout

	la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout

    lw t1, 0(t0)						#t1 = tam buffer entrada
\end_layout

\begin_layout Plain Layout

    blt s1, t1, leer_archivo	   #Si bytes leidos < tam vuelve a leer
\end_layout

\begin_layout Plain Layout

    beq s1, t1, leer_caracter	        #Si ya leyo todo salta
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

eof_fue_leido:
\end_layout

\begin_layout Plain Layout

	la t0, tam_buffer_entrada		#Si leyo menos bytes pero todavia 
\end_layout

\begin_layout Plain Layout

	sw s1, 0(t0)					#hay cosas en el buffer
\end_layout

\begin_layout Plain Layout

	             					#Actualizo el tamanio del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

leer_caracter:
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    lw a1, ARG1($fp)                  #Cargo el puntero al buffer
\end_layout

\begin_layout Plain Layout

    addu t2, s0, a1                   #t2 = buffer + pos
\end_layout

\begin_layout Plain Layout

    lbu v0, 0(t2)                     #v0 = caracter leido
\end_layout

\begin_layout Plain Layout

    addiu s0, s0, 1                   #Incremento la posicion actual
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    la t0, pos_buffer_entrada
\end_layout

\begin_layout Plain Layout

    sw s0, 0(t0)                   #Guardamos la pos actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

	lw s0, S0_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw s1, S1_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

leyo_eof:
\end_layout

\begin_layout Plain Layout

	la t0, eof_leido
\end_layout

\begin_layout Plain Layout

	addiu t1,zero,1
\end_layout

\begin_layout Plain Layout

	sw t1, 0(t0)						#Actualizo la variable EOF leido
\end_layout

\begin_layout Plain Layout

	addu v0, zero, zero					#Devuelvo 0
\end_layout

\begin_layout Plain Layout

	b return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

error:
\end_layout

\begin_layout Plain Layout

	addiu v0, zero, -1					#Devuelvo -1 
\end_layout

\begin_layout Plain Layout

	b return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.end getch
\end_layout

\begin_layout Plain Layout

.size getch,.-getch
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''putch.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#include <sys/syscall.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 48
\end_layout

\begin_layout Plain Layout

#define S0_SF 16
\end_layout

\begin_layout Plain Layout

#define S1_SF 20
\end_layout

\begin_layout Plain Layout

#define S2_SF 24
\end_layout

\begin_layout Plain Layout

#define S3_SF 28
\end_layout

\begin_layout Plain Layout

#define FP_SF 32
\end_layout

\begin_layout Plain Layout

#define GP_SF 36
\end_layout

\begin_layout Plain Layout

#define RA_SF 40
\end_layout

\begin_layout Plain Layout

#define ARG0 48
\end_layout

\begin_layout Plain Layout

#define ARG1 52
\end_layout

\begin_layout Plain Layout

#define ARG2 56
\end_layout

\begin_layout Plain Layout

#define ASCII_NEWLINE 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl putch
\end_layout

\begin_layout Plain Layout

.ent putch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

putch:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	sw s0, S0_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw s1, S1_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw s2, S2_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw s3, S3_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)                 #Guardamos el archivo de salida
\end_layout

\begin_layout Plain Layout

	sw a1, ARG1($fp)                 #Guardamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout

    sw a2, ARG2($fp)                 #Guardamos el buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    la t0, pos_buffer_salida
\end_layout

\begin_layout Plain Layout

    lw s0, 0(t0)                     #s0 = pos actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    addu s1, zero, zero              #s1 = indice de la palabra = 0
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    la t0, eof_leido
\end_layout

\begin_layout Plain Layout

    lw t1, 0(t0)                     #t1 = eof debe ser escrito?
\end_layout

\begin_layout Plain Layout

    beq t1,zero, loop     		     #Salta si eof no debe ser escrito
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

#Si no salta es la ultima escritura en el archivo
\end_layout

\begin_layout Plain Layout

    move s3, zero					 #s3 = cant bytes escritos = 0
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout

    sw s0, 0(t0)                     #Actualiza el tamanio del buffer 
\end_layout

\begin_layout Plain Layout

									 #a la posicion actual
\end_layout

\begin_layout Plain Layout

    b escribir_todo
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

loop:
\end_layout

\begin_layout Plain Layout

    lw a1, ARG1($fp)                 #Cargamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout

    addu t3, a1, s1                  #t3 = palabra + indice
\end_layout

\begin_layout Plain Layout

    lbu s2, 0(t3)                    #s2 = caracter a escribir
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    lw a2, ARG2($fp)                 #Cargamos el puntero al buffer
\end_layout

\begin_layout Plain Layout

    addu t5, a2, s0                  #t5 = buffer + pos_actual
\end_layout

\begin_layout Plain Layout

    sb s2, 0(t5)                     #Guardamos el caracter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    addiu s0,s0,1                    #Incrementamos pos_actual
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout

    lw t1, 0(t0)                     #Cargamos el tamanio del buffer
\end_layout

\begin_layout Plain Layout

    bltu s0, t1, continuar_loop      #Salta si pos_actual < tam_buffer
\end_layout

\begin_layout Plain Layout

    move s3, zero					 #s3 = cant bytes escritos = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Si no salta hay que volver a escribir el archivo y vaciar el buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

escribir_todo:
\end_layout

\begin_layout Plain Layout

    lw a0, ARG0($fp)                 #Cargamos el archivo de salida 
\end_layout

\begin_layout Plain Layout

    lw a1, ARG2($fp)                 #Cargamos el buffer 
\end_layout

\begin_layout Plain Layout

    addu a1, a1, s3					 #a1 = buffer + cant bytes escritos
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout

    lw a2, 0(t0)                     #Cargamos tam total del buffer 
\end_layout

\begin_layout Plain Layout

    subu a2, a2, s3					 #a2 = tam - cant bytes escritos
\end_layout

\begin_layout Plain Layout

    li v0, SYS_write
\end_layout

\begin_layout Plain Layout

    syscall
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    bne a3, zero, error			     #Salta si ocurrio un error
\end_layout

\begin_layout Plain Layout

    addu s3, s3, v0					 #s3 = cant bytes escritos
\end_layout

\begin_layout Plain Layout

    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout

    lw t1, 0(t0)                     # t1 = tamanio total del buffer 
\end_layout

\begin_layout Plain Layout

    blt s3, t1, escribir_todo       #Si escribio menos vuelve a escribir
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    addu s0, zero, zero              #Pos_actual = 0
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    la t0, eof_leido
\end_layout

\begin_layout Plain Layout

    lw t1, 0(t0)                     #t1 = eof escrito ?
\end_layout

\begin_layout Plain Layout

    bgt t1, zero, terminar      	 #Termina si EOF fue escrito
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

continuar_loop:
\end_layout

\begin_layout Plain Layout

    addu s1, s1, 1                   #Incrementa el indice de la palabra
\end_layout

\begin_layout Plain Layout

    bne s2, ASCII_NEWLINE, loop      #Vuelve al loop si no es 
\backslash
n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

terminar:
\end_layout

\begin_layout Plain Layout

	addiu v0, zero, 1			      #Devuelve 1 si no ocurrio un error
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

    la t0, pos_buffer_salida
\end_layout

\begin_layout Plain Layout

    sw s0, 0(t0)    				  #Actualiza la posicion actual                
  
\end_layout

\begin_layout Plain Layout

    lw s0, S0_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw s1, S1_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw s2, S2_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw s3, S3_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

error:
\end_layout

\begin_layout Plain Layout

	move v0, zero						#Devuelve 0 si ocurrio un error
\end_layout

\begin_layout Plain Layout

	b return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.end putch
\end_layout

\begin_layout Plain Layout

.size putch,.-putch
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''crear_buffer.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 32
\end_layout

\begin_layout Plain Layout

#define FP_SF 16
\end_layout

\begin_layout Plain Layout

#define GP_SF 20
\end_layout

\begin_layout Plain Layout

#define RA_SF 24
\end_layout

\begin_layout Plain Layout

#define ARG0 32
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl crear_buffer
\end_layout

\begin_layout Plain Layout

.ent crear_buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

crear_buffer:
\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)               #Guardamos el tamanio del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    la t9, mymalloc                    
\end_layout

\begin_layout Plain Layout

    jalr t9                        #Llama a malloc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return:							
\end_layout

\begin_layout Plain Layout

    lw ra, RA_SF($fp)			
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.end crear_buffer
\end_layout

\begin_layout Plain Layout

.size crear_buffer,.-crear_buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''leer_palabra.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 40
\end_layout

\begin_layout Plain Layout

#define S0_SF 24
\end_layout

\begin_layout Plain Layout

#define FP_SF 28
\end_layout

\begin_layout Plain Layout

#define GP_SF 32
\end_layout

\begin_layout Plain Layout

#define RA_SF 36
\end_layout

\begin_layout Plain Layout

#define ARG0 40
\end_layout

\begin_layout Plain Layout

#define ARG1 44
\end_layout

\begin_layout Plain Layout

#define ARG2 48
\end_layout

\begin_layout Plain Layout

#define POINTER 16
\end_layout

\begin_layout Plain Layout

#define ASCII_A_MAY 65
\end_layout

\begin_layout Plain Layout

#define ASCII_Z_MAY 90
\end_layout

\begin_layout Plain Layout

#define ASCII_A_MIN 97
\end_layout

\begin_layout Plain Layout

#define ASCII_Z_MIN 122
\end_layout

\begin_layout Plain Layout

#define ASCII_CERO 48
\end_layout

\begin_layout Plain Layout

#define ASCII_NUEVE 57
\end_layout

\begin_layout Plain Layout

#define ASCII_GUION 45
\end_layout

\begin_layout Plain Layout

#define ASCII_GUIONBAJO 95
\end_layout

\begin_layout Plain Layout

#define ASCII_NEWLINE 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl leer_palabra
\end_layout

\begin_layout Plain Layout

.ent leer_palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

leer_palabra:
\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

    sw s0, S0_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)                  #Guardamos el puntero al archivo 
\end_layout

\begin_layout Plain Layout

	sw a1, ARG1($fp)                  #Guardamos el puntero a longitud
\end_layout

\begin_layout Plain Layout

    sw a2, ARG2($fp)                  #Guardamos el puntero al buffer
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    la t0, TAM
\end_layout

\begin_layout Plain Layout

	lw a0, 0(t0)            		  #Carga TAM en a0     
\end_layout

\begin_layout Plain Layout

	la t9, mymalloc
\end_layout

\begin_layout Plain Layout

	jalr t9             			  #Llama a malloc
\end_layout

\begin_layout Plain Layout

	beq v0, zero, terminar_con_error	#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sw v0, POINTER($fp)          	  #Guardamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout

	addu s0, zero, zero     		  #Inicializamos len(palabra) en 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

loop:
\end_layout

\begin_layout Plain Layout

	lw a0, ARG0($fp)                  #Recuperamos el puntero al archivo
\end_layout

\begin_layout Plain Layout

    lw a1, ARG2($fp)                  #Recuperamos el puntero al buffer
\end_layout

\begin_layout Plain Layout

	la t9, getch
\end_layout

\begin_layout Plain Layout

	jalr t9                           #Leemos un caracter, queda en v0
\end_layout

\begin_layout Plain Layout

	beq v0, -1, error		          #Si devuelve -1 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	beq v0, ASCII_GUION, es_caracter       #Salta si es -
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	beq v0, ASCII_GUIONBAJO, es_caracter   #Salta si es _
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sgeu t0, v0, ASCII_A_MAY               #Mayor que "A"
\end_layout

\begin_layout Plain Layout

	sleu t1, v0, ASCII_Z_MAY               #Menor que "Z"
\end_layout

\begin_layout Plain Layout

	beq t0, t1, es_caracter                #Salta si es letra mayuscula
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sgeu t0, v0, ASCII_A_MIN               #Mayor que "a"
\end_layout

\begin_layout Plain Layout

	sleu t1, v0, ASCII_Z_MIN               #Menor que "z"
\end_layout

\begin_layout Plain Layout

	beq t0, t1, es_caracter                #Salta si es letra minuscula
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sgeu t0, v0, ASCII_CERO                #Mayor que "0"
\end_layout

\begin_layout Plain Layout

	sleu t1, v0, ASCII_NUEVE               #Menor que "9"
\end_layout

\begin_layout Plain Layout

	beq t0, t1, es_caracter                #Salta si es un numero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

no_es_caracter:
\end_layout

\begin_layout Plain Layout

	lw a0, POINTER($fp)               #Recuperamos puntero a palabra
\end_layout

\begin_layout Plain Layout

	addu t0, s0, a0                   #t0 = palabra + len
\end_layout

\begin_layout Plain Layout

	addiu t1, zero, ASCII_NEWLINE
\end_layout

\begin_layout Plain Layout

	sb t1, 0(t0)                      #Guardamos el "
\backslash
n"
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	lw a1, ARG1($fp)	              #Cargamos puntero a len
\end_layout

\begin_layout Plain Layout

	sw s0, 0(a1)                      #Guardamos el len
\end_layout

\begin_layout Plain Layout

	b terminar                        #Sale del loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

es_caracter:
\end_layout

\begin_layout Plain Layout

	lw a0, POINTER($fp)               #Recuperamos puntero a palabra
\end_layout

\begin_layout Plain Layout

	addu t0, s0, a0                   #t0 = palabra + len
\end_layout

\begin_layout Plain Layout

	sb v0, 0(t0)                      #Guardamos el caracter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	addiu s0, s0, 1                   #Incrementamos len en 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	la t0, TAM
\end_layout

\begin_layout Plain Layout

	lw t1, 0(t0)                      #Carga TAM en t1  
\end_layout

\begin_layout Plain Layout

	remu t2, s0, t1                   #t2 = len % tam
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	bne t2, zero, loop                #Salta si el modulo no es 0
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	lw a0, POINTER($fp)               #a0 =  puntero a palabra
\end_layout

\begin_layout Plain Layout

	move a1, s0						  #a1 = len
\end_layout

\begin_layout Plain Layout

	la t0, TAM
\end_layout

\begin_layout Plain Layout

	lw a2, 0(t0)            		  #a2 = TAM
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	la t9, myrealloc
\end_layout

\begin_layout Plain Layout

	jalr t9                           #Llama a realloc
\end_layout

\begin_layout Plain Layout

	beq v0, zero, error	              #Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

	sw v0, POINTER($fp)          	  #Guardamos el nuevo puntero 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	b loop                            #Vuelve siempre al loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

terminar:
\end_layout

\begin_layout Plain Layout

	lw v0, POINTER($fp)               #v0 = puntero a la palabra
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

    lw s0, S0_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

error:
\end_layout

\begin_layout Plain Layout

	lw a0, POINTER($fp)              # Recuperamos puntero a palabra
\end_layout

\begin_layout Plain Layout

	la t9, myfree
\end_layout

\begin_layout Plain Layout

	jalr t9						     #Llama a free con la palabra
\end_layout

\begin_layout Plain Layout

terminar_con_error:
\end_layout

\begin_layout Plain Layout

	move v0, zero					 #Devuelve 0 si ocurrio un error
\end_layout

\begin_layout Plain Layout

	b return						
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

.end leer_palabra
\end_layout

\begin_layout Plain Layout

.size leer_palabra,.-leer_palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''es_capicua.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 48
\end_layout

\begin_layout Plain Layout

#define S0_SF 24
\end_layout

\begin_layout Plain Layout

#define S1_SF 28
\end_layout

\begin_layout Plain Layout

#define FP_SF 32
\end_layout

\begin_layout Plain Layout

#define GP_SF 36
\end_layout

\begin_layout Plain Layout

#define RA_SF 40
\end_layout

\begin_layout Plain Layout

#define ARG0 48
\end_layout

\begin_layout Plain Layout

#define ARG1 52
\end_layout

\begin_layout Plain Layout

#define CHAR1 16
\end_layout

\begin_layout Plain Layout

#define CHAR2 20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl es_capicua
\end_layout

\begin_layout Plain Layout

.ent es_capicua
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

es_capicua:
\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

    sw s0, S0_SF(sp)
\end_layout

\begin_layout Plain Layout

    sw s1, S1_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)          	# Guardamos el puntero a la palabra 
\end_layout

\begin_layout Plain Layout

	sw a1, ARG1($fp)          	# Guardamos la longitud 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	beq a1, zero, return_false  #Si len es 0 devuelve false
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	addu s0, zero, zero         #Inicializamos la variable inicio
\end_layout

\begin_layout Plain Layout

	subu s1, a1, 1              #Inicializamos la variable final
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

loop:
\end_layout

\begin_layout Plain Layout

	lw t0, ARG0($fp)          	#Recuperamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout

    addu t0, t0, s0         	#t0 = palabra + inicio
\end_layout

\begin_layout Plain Layout

	lbu a0, 0(t0)           	# Leemos el  caracter palabra[inicio]
\end_layout

\begin_layout Plain Layout

	la t9, my_tolower       
\end_layout

\begin_layout Plain Layout

	jalr t9              	    #Llamamos a tolower() con el caracter
\end_layout

\begin_layout Plain Layout

	sw v0, CHAR1($fp)           #Guardamos el caracter en minuscula
\end_layout

\begin_layout Plain Layout

	lw a0, ARG0($fp)            #Recuperamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout

    addu t0, a0, s1             #t0 = palabra + final
\end_layout

\begin_layout Plain Layout

	lbu a0, 0(t0)	            #Leemos el  caracter palabra[final]
\end_layout

\begin_layout Plain Layout

	la t9, my_tolower
\end_layout

\begin_layout Plain Layout

	jalr t9              	    #Llamamos a tolower() con el caracter
\end_layout

\begin_layout Plain Layout

	sw v0, CHAR2($fp)           #Guardamos el caracter en minuscula
\end_layout

\begin_layout Plain Layout

	move t0, v0                 #t0 = segundo caracter
\end_layout

\begin_layout Plain Layout

	lw t1, CHAR1($fp)           #t1 = primer caracter
\end_layout

\begin_layout Plain Layout

	bne t0, t1, return_false    #Si son distintos devuelve false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	addiu s0, s0, 1             #Suma uno (un byte) a inicio
\end_layout

\begin_layout Plain Layout

	subu s1, s1, 1              #Resta uno (un byte) a final
\end_layout

\begin_layout Plain Layout

	blt s0, s1, loop		    #Si inicio < final vuelve al loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return_true:
\end_layout

\begin_layout Plain Layout

	addiu v0, zero, 1
\end_layout

\begin_layout Plain Layout

	b return
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return_false:
\end_layout

\begin_layout Plain Layout

	addu v0, zero, zero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

	lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw s1, S1_SF($fp)
\end_layout

\begin_layout Plain Layout

    lw s0, S0_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.end es_capicua
\end_layout

\begin_layout Plain Layout

.size es_capicua,.-es_capicua
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''my_tolower.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 24
\end_layout

\begin_layout Plain Layout

#define FP_SF 16
\end_layout

\begin_layout Plain Layout

#define GP_SF 20
\end_layout

\begin_layout Plain Layout

#define ARG0 24
\end_layout

\begin_layout Plain Layout

#define ASCII_A_MAY 65
\end_layout

\begin_layout Plain Layout

#define ASCII_Z_MAY 90
\end_layout

\begin_layout Plain Layout

#define DIF_MAY_MIN 32
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl my_tolower
\end_layout

\begin_layout Plain Layout

.ent my_tolower
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

my_tolower:
\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)                   #Guardamos el caracter
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	blt a0, ASCII_A_MAY, return        #Salta si caracter es menor a A
\end_layout

\begin_layout Plain Layout

	bgt a0, ASCII_Z_MAY, return        #Salta si caracter es mayor a Z
\end_layout

\begin_layout Plain Layout

	addiu a0, a0, DIF_MAY_MIN          #Convierte a minuscula
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

	move v0, a0                        #Pone el resultado en v0
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

.end my_tolower
\end_layout

\begin_layout Plain Layout

.size my_tolower,.-my_tolower 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ''myrealloc.S''
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout

#define TAM_SF 40
\end_layout

\begin_layout Plain Layout

#define S0_SF 24
\end_layout

\begin_layout Plain Layout

#define FP_SF 28
\end_layout

\begin_layout Plain Layout

#define GP_SF 32
\end_layout

\begin_layout Plain Layout

#define RA_SF 36
\end_layout

\begin_layout Plain Layout

#define ARG0 40
\end_layout

\begin_layout Plain Layout

#define ARG1 44
\end_layout

\begin_layout Plain Layout

#define ARG2 48
\end_layout

\begin_layout Plain Layout

#define NEW_POINTER 16
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.text
\end_layout

\begin_layout Plain Layout

.abicalls
\end_layout

\begin_layout Plain Layout

.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.globl myrealloc
\end_layout

\begin_layout Plain Layout

.ent myrealloc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myrealloc:							
\end_layout

\begin_layout Plain Layout

	.frame $fp, TAM_SF, ra
\end_layout

\begin_layout Plain Layout

	.set noreorder
\end_layout

\begin_layout Plain Layout

	.cpload t9
\end_layout

\begin_layout Plain Layout

	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	subu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	sw s0, S0_SF(sp)
\end_layout

\begin_layout Plain Layout

	sw $fp, FP_SF(sp)
\end_layout

\begin_layout Plain Layout

	.cprestore GP_SF
\end_layout

\begin_layout Plain Layout

	sw ra, RA_SF(sp)
\end_layout

\begin_layout Plain Layout

	move $fp, sp
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw a0, ARG0($fp)             # guardamos el puntero
\end_layout

\begin_layout Plain Layout

	sw a1, ARG1($fp)             # guardamos el tamanio del bloque
\end_layout

\begin_layout Plain Layout

    sw a2, ARG2($fp)             # guardamos el tamanio a agregar
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	addu a0, a1, a2				 #a0 = nuevo tamanio bloque
\end_layout

\begin_layout Plain Layout

	la t9, mymalloc
\end_layout

\begin_layout Plain Layout

	jalr t9						 #Llama a malloc
\end_layout

\begin_layout Plain Layout

	beq v0, zero, return		 #Si devuelve cero ocurrio un error
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sw v0, NEW_POINTER($fp)		 #Guardamos el puntero nuevo
\end_layout

\begin_layout Plain Layout

	addu s0, zero, zero			 #s0 = indice actual
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

loop:
\end_layout

\begin_layout Plain Layout

	lw t0, ARG1($fp)			 #t0 = tamanio original
\end_layout

\begin_layout Plain Layout

	bgeu s0, t0, terminar		 #salta si ya copio todo
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	lw t0, ARG0 ($fp)			 #t0 = puntero viejo
\end_layout

\begin_layout Plain Layout

	addu t0, t0, s0				 #t0 = puntero viejo + indice
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	lw t1, NEW_POINTER($fp)		 #t1 = puntero nuevo
\end_layout

\begin_layout Plain Layout

	addu t1, t1, s0				 #t1 = puntero nuevo + indice
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	lbu t2, 0(t0)				 #Cargo el byte a copiar en t2
\end_layout

\begin_layout Plain Layout

	sb t2, 0(t1)				 #Guardo el byte
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	addiu s0, s0, 1				 #incremento el indice
\end_layout

\begin_layout Plain Layout

	b loop						 #Vuelve al loop
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

terminar:
\end_layout

\begin_layout Plain Layout

	lw a0, ARG0($fp)			 #a0 = puntero viejo
\end_layout

\begin_layout Plain Layout

	la t9, myfree
\end_layout

\begin_layout Plain Layout

	jalr t9						 #Libera el puntero viejo
\end_layout

\begin_layout Plain Layout

	lw v0, NEW_POINTER($fp)		 #v0 = puntero nuevo
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

return:
\end_layout

\begin_layout Plain Layout

	lw s0, S0_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw ra, RA_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw gp, GP_SF($fp)
\end_layout

\begin_layout Plain Layout

	lw $fp, FP_SF($fp)
\end_layout

\begin_layout Plain Layout

	addiu sp, sp, TAM_SF
\end_layout

\begin_layout Plain Layout

	jr ra
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

.end myrealloc
\end_layout

\begin_layout Plain Layout

.size myrealloc,.-myrealloc 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename tp1-2017-2q.pdf
	extra LaTeX "pages =-"

\end_inset


\end_layout

\end_body
\end_document
