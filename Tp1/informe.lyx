#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\date{}
\usepackage{float}
\usepackage{units}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{esint}
%\numberwithin{figure}{section}
%\numberwithin{table}{section}
%\numberwithin{equation}{section}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{xcolor}
%-------------------------------------------------------------------------------
%Modificaciones de leyendas en figuras
%\usepackage[footnotesize, labelsep=quad]{caption}
%\captionsetup{width=0.8\textwidth }
\usepackage{caption}
\captionsetup[figure]{margin=40pt,font=normalsize,labelfont=bf}
\captionsetup[table]{margin=40pt,font=normalsize,labelfont=bf} 
%-------------------------------------------------------------------------------
% Added by lyx2lyx
\end_preamble
\use_default_options true
\begin_modules
customHeadersFooters
tcolorbox
fixltx2e
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_author "Agustín Zorzano"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
Organización de Computadoras (66.20)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.5]{fiuba.png}
\backslash

\backslash
[1.5cm]    
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Facultad de Ingeniería - U.B.A.}
\backslash

\backslash
[1.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large 66.20 Organización de Computadoras - Práctica Martes}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small 2do.
 Cuatrimestre de 2017}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout

 { 
\backslash
Huge 
\backslash
bfseries Trabajo práctico Nº 1}
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout

{ 
\backslash
huge Programación MIPS}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Matias Leandro Feld, Padrón: 99170}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

feldmatias@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Federico Funes, Padrón: 98372}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

fede.funes96@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
small Agustín Zorzano, Padrón: 99224}
\backslash

\backslash
[.05cm]
\end_layout

\begin_layout Plain Layout

aguszorza@gmail.com
\backslash

\backslash
[.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

% Bottom of the page {
\backslash
large 
\backslash
today}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Documentación e implementación
\end_layout

\begin_layout Standard

\color black
El objetivo del trabajo es realizar un programa en lenguaje MIPS32 que lea
 palabras de una archivo (o de entrada estandar) y guarde en otro archivo
 (mostrar por salida estandar) únicamente aquellas palabras que sean palíndromos.
 Además, para analizar como influyen en el tiempo de ejecución las lecturas
 y escrituras en archivos, se implementó un sistema de buffer.
 Esto significa que al leer de un archivo no se hará de a un caracter por
 vez, sino que se llenará el buffer de entrada y luego se leerán los caracteres
 desde éste.
 Asimismo, para la escritura de archivos se realizará algo similar.
 Se guardarán en el buffer los caracteres a escribir, y se escribirán en
 el archivo una vez que el buffer se llene.
 De este modo, variando el tamaño del buffer, se podrá analizar como afectan
 al tiempo las operaciones con archivos.
\end_layout

\begin_layout Standard

\color black
El programa se divide en las siguientes funciones: 
\end_layout

\begin_layout Enumerate

\color black
La función principal, main, que se encargara de la lógica de leer los parámetros
 de entrada y el manejo de los archivos.
 Si algun archivo no se puede abrir, no se pasaron correctamente los parámetros
 el programa, o se produjo un error en la ejecución, mostrará un mensaje
 de error en el archivo stderr y finalizará con un código de error.
 Esta funcion será escrita en lenguaje C.
\end_layout

\begin_layout Enumerate
La función palindrome, que es la que se encarga del bucle principal.
 
\color black
que consiste en leer una palabra del archivo de entrada, comprobar si es
 palíndromo y escribirla en el archivo de salida si corresponde.
 Ésta es la función de entrada al programa en MIPS que deberá ser llamada
 desde el programa en C.
 Recibe por parámetro el archivo de entrada, el de salida y los tamaños
 de los buffer.
 Al ser llamada lo primero que hará es crear los buffer de entrada y salida,
 utilizando la función crear_buffer().
 Luego entrará en el bucle hasta que todos los caracteres del archivo de
 entrada sean analizados.
 El bucle termina cuando se lee el EOF, y en este caso se llamará una vez
 más a la funciónque escribe en archivos para escribir todo lo que haya
 quedado en el buffer de salida.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de leer_archivo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\color black
La función leer palabra, que se encarga de leer una palabra del archivo.
 Debido a las limitaciones de lo que se considera palabra, y a que no hay
 limitación con respecto a cantidad de letras de una palabra, lo que hacemos
 es leer carácter por carácter, guardándolos en un vector alojado en memoria
 dinámica que se irá redimensionando a medida que sea necesario.
 Para ello, definimos una variable TAM que determinará la cantidad de memoria
 que se pide al inicio y al redimensionar.
 En principio esa variable puede contener cualquier número, pero para no
 estar redimensionando muchas veces y para no pedir mucha memoria innecesaria,
 definimos ese valor en 50.
 La función recibe por parámetro un puntero a entero, que sirve para guardar
 la longitud de la palabra leída, con el objetivo de no tener que calcularla
 nuevamente en otro momento.
 Para leer un caracter llamará a la función getch().
 Para facilitar la escritura de la palabra, al final de la misma se insertará
 un 
\backslash
n en lugar de un 
\backslash
0.
 El stackframe correspondiente a la función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_palabra.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de leer_palabra
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\color black
La función es capicúa, que se encarga de comprobar si la palabra es o no
 un palíndromo, y devuelve un valor booleano según corresponda.
 Ésta función recibe por parámetro el puntero a la palabra y la longitud
 de la misma.
 El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_es_capicua.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de es_capicua
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función my_tolower, que fue implementada para reemplazar la del lenguaje
 C, se encarga de pasar a minúscula un caracter.
 Para eso, recibe por parámetro el caracter, y lo transforma únicamente
 si es una letra mayúscula, caso contrario lo devuelve como viene.
 
\color black
El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_my_tolower.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de my_tolower
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función crear buffer, es la encargada de crear los buffers.
 Para ello recibirá por parámetro el tamaño del mismo, y lo creará haciendo
 uso de la función malloc.
 
\color black
El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_crear_buffer.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de crear_buffer
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función getch, que se encarga de leer un carácter del archivo de entrada.
 Como se explicó anteriormente, ésta hace uso de un buffer.
 Por lo tanto, conociendo el tamaño del buffer y la última posición leída,
 devolverá el caracter correspondiente, y cuando la posición sea mayor o
 igual al tamaño se encargará de llenar el buffer nuevamente con nuevos
 datos.
 Esta función tiene una complicación adicional, ya que debe indicar cuando
 fue leído el final del archivo en el buffer.
 Para eso, utilizaremos una variable global, que será nula hasta el momento
 en que se lee el EOF, que cambiará de valor y permitirá avisar a las demás
 funciones que ya se leyó todo el archivo.
 Si se produjera algún error en la lectura devolverá un código de error.
 Para la lectura del archivo hace uso de un syscall.
 Puede ocurrir que se lean menos bytes de los pedidos, en ese caso pueden
 ser por dos razones, que no hay más por leer o que se leyó menos pero se
 puede leer más.
 Esto lo solucionamos haciendo que la lectura se haga en un loop, que termina
 cuando no hay más para leer o cuando se llenó el buffer.
 
\color black
El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_leer_caracter_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de getch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
La función putch, que se encarga de escribir una palabra en el archivo de
 salida.
 Debido a que debe utilizar el buffer, la función recibirá por parámetro
 la palabra, y guardará de a un caracter por vez en el buffer.
 Una vez que se llene el buffer, independientemente si se guardó toda la
 palabra o no, éste se escribirá en el archivo y se vaciará.
 Al igual que la anterior, también tiene una complicación.
 Puede ocurrir que el buffer no se llene completamente y se haya terminado
 el archivo, en cuyo caso, utilizando la variable global que indica si se
 debe escribir el EOF, escribirá todo lo que se encuentre en el buffer en
 ese momento.
 
\color black
El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_escribir_palabra_archivo.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de putch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Por último, la función myrealloc, que sirve para redimensionar un bloque
 de memoria dinámica.
 Para facilitar la programación de la misma, se decidió que solo se podrá
 redimensionar aumentando el tamaño del bloque y no disminuyéndolo.
 Por eso, la función recibe por parámetro el puntero al bloque, el tamaño
 actual, y el tamaño a agregar.
 Haciendo uso de la función mymalloc crea un nuevo bloque y copia byte por
 byte los datos del bloque viejo al nuevo.
 Finalmente libera el bloque viejo y devuelve el nuevo.
 Si se produjera un error al llamar a la función mymalloc se devolverá un
 puntero a NULL.
 
\color black
El stackframe correspondiente a esta función quedará definido de la siguiente
 manera:
\color inherit

\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imagenes/stackframe_myrealloc.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Stackframe de myrealloc
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Comandos para compilacion
\end_layout

\begin_layout Standard
Para compilar el programa utilizamos el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ gcc -Wall -o tp1 main.c mymalloc.S myrealloc.S palindrome.S
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
o se puede optar por ejecutar el script de bash:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ ./compilar.sh
\end_layout

\begin_layout Section
Pruebas
\end_layout

\begin_layout Standard
Para probar el programa utilizamos un script de bash llamado 'pruebas.sh''
 que contiene un conjunto de pruebas que se realizan automáticamente.
 Entre ellas,se encuentran pruebas con archivos vacios, archivos con un
 solo caracter y archivos solo con simbolos.
 Por otro lado, tambien se prueba que funcionen correctamente los mensajes
 de error cuando los parámetros no son usados correctamente.
 Se realizan pruebas para distintos tamaños de buffer para asegurarnos que
 funcione correctamente.
 Todas las pruebas utilizan el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
$ diff salida.txt resultado.txt
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde si no muestra nada significa que ambos archivos son iguales, y que
 por lo tanto todas las pruebas del programa funcionan correctamente.
\end_layout

\begin_layout Standard
En una de las pruebas utilizamos un archivo de texto ''entrada.txt'' que
 contiene un conjunto de palabras con combinaciones de letras, numeros y
 guiones y mezclando mayúsculas y minúsculas.
 Luego tenemos otro archivo, ''resultado.txt'' que es lo que se espera que
 devuelva el programa al ejecutarse con ese archivo de entrada.
 En la siguiente sección se muestran esos archivos.
 En el resto de las pruebas se usan archivos creados dentro del mismo script,
 que se borran al finalizar.
\end_layout

\begin_layout Standard
También realizamos pruebas utilizando salida estándar y entrada estándar,
 los cuales funcionaron correctamente.
 Cuando se trabaja con entrada estándar y se desea finalizar se debe ingresar
 ''ctrl D'', que inserta un EOF, ya que utilizando ''ctrl C'' finaliza abruptame
nte y no se guarda correctamente el resultado.
\end_layout

\begin_layout Subsection
Archivo 'pruebas.sh'
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout
#/bin/bash
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
./compilar.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
if [ -f time.txt ]; then
\end_layout

\begin_layout Plain Layout
    rm time.txt
\end_layout

\begin_layout Plain Layout
fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con archivo de pruebas entrada.txt y resultado.txt
\end_layout

\begin_layout Plain Layout
echo -e "PRUEBAS CON ARCHIVO DE PRUEBAS ENTRADA.TXT Y RESULTADO.TXT
\backslash
n" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "Resultado con 1 byte entrada y 1 byte salida:" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 1 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 20 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 100 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 100 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1000 bytes entrada y 1000 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 1000 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 100 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 20 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 100 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1 byte entrada y 100 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 1 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 1 byte salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 100 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 1000 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 20 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1000 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i entrada.txt -o salida.txt -I 1000 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba con archivo vacio
\end_layout

\begin_layout Plain Layout
touch vacio.txt
\end_layout

\begin_layout Plain Layout
touch resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i vacio.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado_vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con una sola letra mayúscula
\end_layout

\begin_layout Plain Layout
echo M > res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo M | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con una sola letra minúscula
\end_layout

\begin_layout Plain Layout
echo m > res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo m | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba con un número
\end_layout

\begin_layout Plain Layout
echo 3 > res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo 3 | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con un guion
\end_layout

\begin_layout Plain Layout
echo - > res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo - | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con un guion bajo
\end_layout

\begin_layout Plain Layout
echo _ > res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout
echo _ | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con un simbolo
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
echo @ | ./tp1 -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba con espacios
\end_layout

\begin_layout Plain Layout
echo "                    " > ent.txt 
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Pruebas con simbolos
\end_layout

\begin_layout Plain Layout
echo "@#$%^*()!{}[],./?<>;:*+
\backslash
|=+" > ent.txt 
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1000 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1 -O 100
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 100 -O 1
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 20 -O 1000
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i ent.txt -o salida.txt -I 1000 -O 20
\end_layout

\begin_layout Plain Layout
diff salida.txt vacio.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Prueba con un archivo con 30 lineas de 5000 caracteres cada una,
\end_layout

\begin_layout Plain Layout
# donde cada una es palindromo en su totalidad
\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nPRUEBAS CON ARCHIVO CON LINEAS DE 5000 CARACTERES CADA UNA (TODAS SON PALINDROM
O)
\backslash
n" >> time.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1 byte entrada y 1 byte salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 100 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1000 bytes entrada y 1000 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1000 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 100 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1 byte entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1 -O 100)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 100 bytes entrada y 1 byte salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 100 -O 1)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 20 bytes entrada y 1000 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 20 -O 1000)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
echo -e "
\backslash
nResultado con 1000 bytes entrada y 20 bytes salida:" >> time.txt
\end_layout

\begin_layout Plain Layout
(time ./tp1 -i archivo_largo.txt -o salida.txt -I 1000 -O 20)2>>time.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt archivo_largo.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: no se ingresa archivo de entrada
\end_layout

\begin_layout Plain Layout
echo "Debe indicar un archivo de entrada luego de -i" > res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -i 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -O 10 -i 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -i 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: no se ingresa archivo de salida
\end_layout

\begin_layout Plain Layout
echo "Debe indicar un archivo de salida luego de -o" > res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -o 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -o 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -O 10 -o 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: no se ingresa tamaño del buffer de entrada
\end_layout

\begin_layout Plain Layout
echo "Debe indicar un numero luego de -I" > res.txt       
\end_layout

\begin_layout Plain Layout
./tp1 -I 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -O 10 -I 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -O 10 -I 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: no se ingresa tamaño del buffer de salida
\end_layout

\begin_layout Plain Layout
echo "Debe indicar un numero luego de -O" > res.txt     
\end_layout

\begin_layout Plain Layout
./tp1 -O 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -O 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -O 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 10 -O 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: no se puede abrir el archivo de entrada
\end_layout

\begin_layout Plain Layout
echo "El archivo de entrada no pudo abrirse" > res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -i inexistente.txt 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i inexistente.txt -I 10 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: el tamaño del buffer de entrada no es un numero
\end_layout

\begin_layout Plain Layout
echo "El parametro de -I debe ser un numero" > res.txt			
\end_layout

\begin_layout Plain Layout
./tp1 -I abc 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I numero 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -O 10 -I nueve 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -O 10 -I abc123 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# Prueba error: el tamaño del buffer de salida no es un numero
\end_layout

\begin_layout Plain Layout
echo "El parametro de -O debe ser un numero" > res.txt			
\end_layout

\begin_layout Plain Layout
./tp1 -O abc 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -O numero 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -I 10 -O nueve 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 10 -O abc123 2> error.txt
\end_layout

\begin_layout Plain Layout
diff error.txt res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Pruebas con stdin (sin poner '-i' o poniendo '-i -')
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 1 -O 1  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 20 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 100 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 1000 -O 1000  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 20 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -o salida.txt -I 100 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i - -o salida.txt -I 1 -O 100  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i - -o salida.txt -I 100 -O 1  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i - -o salida.txt -I 20 -O 1000  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i - -o salida.txt -I 1000 -O 20  < entrada.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Prueba con stdout (sin poner '-o' o poniendo '-o -')
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 1 -O 1 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 20 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 100 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 1000 -O 1000 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 20 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 100 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 1 -O 100 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 100 -O 1 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 20 -O 1000 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout
./tp1 -i entrada.txt -I 1000 -O 20 > salida.txt
\end_layout

\begin_layout Plain Layout
diff salida.txt resultado.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Borramos archivos sobrantes
\end_layout

\begin_layout Plain Layout
rm vacio.txt
\end_layout

\begin_layout Plain Layout
rm resultado_vacio.txt
\end_layout

\begin_layout Plain Layout
rm salida.txt
\end_layout

\begin_layout Plain Layout
rm ent.txt
\end_layout

\begin_layout Plain Layout
rm error.txt
\end_layout

\begin_layout Plain Layout
rm res.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ’entrada.txt’
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

Pruebas varias:
\end_layout

\begin_layout Plain Layout

aaa     pelota hola como estas
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pepep aaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

_aa_
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

_aAAa_
\end_layout

\begin_layout Plain Layout

-a-a-
\end_layout

\begin_layout Plain Layout

-a-a
\end_layout

\begin_layout Plain Layout

Neuquen
\end_layout

\begin_layout Plain Layout

-Neuquen-   neu%q%uen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1234321   ?123?123abc4cba321
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Prueba del enunciado:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Somos los primeros en completar el TP 0.
\end_layout

\begin_layout Plain Layout

Ojo que La fecha de entrega del TP0 es el martes 12 de septiembre.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Palabras largas mezcladas:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abcdefghijklmnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba??=
=
\end_layout

\begin_layout Plain Layout

ABCDEFGHIJKLMnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba??=
=
\end_layout

\begin_layout Plain Layout

EstoesUnPalindromoOMOrdnilapNUSEOTse.........EStono
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas de guiones  guiones bajos:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

__--__???????######$$$$_-_-_@@@@@-_-__-_-!    ---___
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas de palabras de una letra:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a   %%% % 1 2 ^4^ - _ C D
\end_layout

\begin_layout Plain Layout

b  ! @ # $ % ^ & * ( ) = + 
\backslash

\end_layout

\begin_layout Plain Layout

c
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Pruebas solo mayusculas:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AAA ABCDEDCBA   ABC123--321CBA  WXXW
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PALINDROMO  -ABCB-
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo ’resultado.txt’
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

aaa
\end_layout

\begin_layout Plain Layout

pepep
\end_layout

\begin_layout Plain Layout

aaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

aaaaaaaaaaaaaaaa
\end_layout

\begin_layout Plain Layout

_aa_
\end_layout

\begin_layout Plain Layout

_aAAa_
\end_layout

\begin_layout Plain Layout

-a-a-
\end_layout

\begin_layout Plain Layout

Neuquen
\end_layout

\begin_layout Plain Layout

-Neuquen-
\end_layout

\begin_layout Plain Layout

q
\end_layout

\begin_layout Plain Layout

1234321
\end_layout

\begin_layout Plain Layout

123abc4cba321
\end_layout

\begin_layout Plain Layout

Somos
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

Ojo
\end_layout

\begin_layout Plain Layout

abcdefghijklmnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba
\end_layout

\begin_layout Plain Layout

ABCDEFGHIJKLMnopqrstuvwxyz0123456789_---_9876543210zyxwvutsrqponmlkjihgfedcba
\end_layout

\begin_layout Plain Layout

EstoesUnPalindromoOMOrdnilapNUSEOTse
\end_layout

\begin_layout Plain Layout

__--__
\end_layout

\begin_layout Plain Layout

_-_-_
\end_layout

\begin_layout Plain Layout

-_-__-_-
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

-
\end_layout

\begin_layout Plain Layout

_
\end_layout

\begin_layout Plain Layout

C
\end_layout

\begin_layout Plain Layout

D
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

c
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

AAA
\end_layout

\begin_layout Plain Layout

ABCDEDCBA
\end_layout

\begin_layout Plain Layout

ABC123--321CBA
\end_layout

\begin_layout Plain Layout

WXXW
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Archivo archivo_largo.txt
\end_layout

\begin_layout Standard
La función de este archivo es trabajar con varios palíndromos largos para
 así poder apreciar la diferencia en los tiempos de ejecución.
 A continuación se muestra la primer línea de este archivo.
 Las lineas faltantes son una copia de ésta.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "documento hijo/hijo.lyx"

\end_inset


\end_layout

\begin_layout Standard

\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection
Archivo time.txt
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small},tabsize=4"
inline false
status open

\begin_layout Plain Layout
PRUEBAS CON ARCHIVO DE PRUEBAS ENTRADA.TXT Y RESULTADO.TXT
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1 byte entrada y 1 byte salida:
\end_layout

\begin_layout Plain Layout
        0.10 real         0.03 user         0.10 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.06 real         0.00 user         0.07 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 100 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.04 real         0.03 user         0.04 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1000 bytes entrada y 1000 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.05 real         0.03 user         0.03 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 100 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.06 real         0.00 user         0.08 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.05 real         0.02 user         0.05 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1 byte entrada y 100 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.08 real         0.03 user         0.06 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 1 byte salida:
\end_layout

\begin_layout Plain Layout
        0.08 real         0.02 user         0.09 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 1000 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.04 real         0.02 user         0.05 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1000 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        0.06 real         0.02 user         0.05 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
PRUEBAS CON ARCHIVO CON LINEAS DE 5000 CARACTERES CADA UNA (TODAS SON PALINDROMO
)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1 byte entrada y 1 byte salida:
\end_layout

\begin_layout Plain Layout
       19.54 real         2.39 user        17.13 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        3.60 real         2.28 user         1.34 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 100 bytes salida:
\end_layout

\begin_layout Plain Layout
        2.89 real         2.23 user         0.67 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1000 bytes entrada y 1000 bytes salida:
\end_layout

\begin_layout Plain Layout
        2.76 real         2.24 user         0.53 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 100 bytes salida:
\end_layout

\begin_layout Plain Layout
        3.08 real         2.32 user         0.78 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        3.41 real         2.20 user         1.22 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1 byte entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        7.19 real         2.59 user         4.60 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 100 bytes entrada y 1 byte salida:
\end_layout

\begin_layout Plain Layout
       15.26 real         2.29 user        12.98 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 20 bytes entrada y 1000 bytes salida:
\end_layout

\begin_layout Plain Layout
        2.96 real         2.25 user         0.73 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Resultado con 1000 bytes entrada y 20 bytes salida:
\end_layout

\begin_layout Plain Layout
        3.36 real         2.23 user         1.12 sys
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Main.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout
#include <stdio.h>
\end_layout

\begin_layout Plain Layout
#include <stdlib.h>
\end_layout

\begin_layout Plain Layout
#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
extern int palindrome (int ifd, size_t ibytes, int ofd, size_t obytes);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
int main(int argc, char* argv[]){
\end_layout

\begin_layout Plain Layout
	FILE* entrada = stdin;
\end_layout

\begin_layout Plain Layout
	FILE* salida = stdout;
\end_layout

\begin_layout Plain Layout
	int tam_buffer_entrada = 1;
\end_layout

\begin_layout Plain Layout
	int tam_buffer_salida = 1;
\end_layout

\begin_layout Plain Layout
	char* parametro;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	int i;
\end_layout

\begin_layout Plain Layout
	for (i = 1; i < argc; i += 2){
\end_layout

\begin_layout Plain Layout
		if (strcmp(argv[i],"-i") == 0){
\end_layout

\begin_layout Plain Layout
			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout
				fputs("Debe indicar un archivo de entrada luego de -i
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
				return 3;
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout
			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout
				entrada = fopen(argv[i + 1], "r");
\end_layout

\begin_layout Plain Layout
				if (!entrada){
\end_layout

\begin_layout Plain Layout
					fputs("El archivo de entrada no pudo abrirse
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
					return 4;
\end_layout

\begin_layout Plain Layout
				}
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
		else if (strcmp(argv[i],"-o") == 0){
\end_layout

\begin_layout Plain Layout
			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout
				fputs("Debe indicar un archivo de salida luego de -o
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
				return 3;
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout
			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout
				salida = fopen(argv[i + 1], "w");
\end_layout

\begin_layout Plain Layout
				if (!salida){
\end_layout

\begin_layout Plain Layout
					fputs("El archivo de salida no pudo abrirse
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
					return 4;
\end_layout

\begin_layout Plain Layout
				}
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
		else if (strcmp(argv[i],"-I") == 0){
\end_layout

\begin_layout Plain Layout
			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout
				fputs("Debe indicar un numero luego de -I
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
				return 3;
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout
			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout
				tam_buffer_entrada = atoi(parametro);
\end_layout

\begin_layout Plain Layout
				if (tam_buffer_entrada == 0){
\end_layout

\begin_layout Plain Layout
					fputs("El parametro de -I debe ser un numero
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
					return 4;
\end_layout

\begin_layout Plain Layout
				}
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
		else if (strcmp(argv[i],"-O") == 0){
\end_layout

\begin_layout Plain Layout
			if (i + 1 >= argc){
\end_layout

\begin_layout Plain Layout
				fputs("Debe indicar un numero luego de -O
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
				return 3;
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
			parametro = argv[i + 1];
\end_layout

\begin_layout Plain Layout
			if (strcmp(parametro,"-") != 0){
\end_layout

\begin_layout Plain Layout
				tam_buffer_salida = atoi(parametro);
\end_layout

\begin_layout Plain Layout
				if (tam_buffer_salida == 0){
\end_layout

\begin_layout Plain Layout
					fputs("El parametro de -O debe ser un numero
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
					return 4;
\end_layout

\begin_layout Plain Layout
				}
\end_layout

\begin_layout Plain Layout
			}
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
		else if (strcmp(argv[i],"-V") == 0){
\end_layout

\begin_layout Plain Layout
			fprintf(stdout, "TP1 version 1.0001
\backslash
n");
\end_layout

\begin_layout Plain Layout
			return 0;
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
		else if (strcmp(argv[i],"-h") == 0){
\end_layout

\begin_layout Plain Layout
			fprintf(stdout, "Usage:
\backslash
n
\backslash
ntp1 -h
\backslash
ntp1 -V
\backslash
ntp1 [options]
\backslash
n
\backslash
nOptions:
\backslash
n-V, --version  Print version and quit.
\backslash
n-h, --help   Print this information.
\backslash
n-i, --input   Location of the input file.
\backslash
n-o, --output   Location of the output file.
\backslash
n-I, --ibuf-bytes Byte-count of the input buffer.
\backslash
n-O, --obuf-bytes Byte-count of the output buffer.
\backslash
n
\backslash
nExample:
\backslash
ntp0 -i ~/input -o ~/output
\backslash
n");
\end_layout

\begin_layout Plain Layout
			return 0;
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	int resultado = palindrome(fileno(entrada), tam_buffer_entrada, fileno(salida),
 tam_buffer_salida);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	if (resultado != 0){
\end_layout

\begin_layout Plain Layout
		fputs("Ocurrio un error
\backslash
n", stderr);
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	fclose(entrada);
\end_layout

\begin_layout Plain Layout
	fclose(salida);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	return resultado;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Myrealloc.S
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout
#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout
#include <sys/syscall.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.text
\end_layout

\begin_layout Plain Layout
.abicalls
\end_layout

\begin_layout Plain Layout
.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.globl myrealloc
\end_layout

\begin_layout Plain Layout
.ent myrealloc
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
myrealloc:							
\end_layout

\begin_layout Plain Layout
	.frame $fp, 40, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 40
\end_layout

\begin_layout Plain Layout
	sw s0, 24(sp)
\end_layout

\begin_layout Plain Layout
	sw $fp, 28(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 32
\end_layout

\begin_layout Plain Layout
	sw ra, 36(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 40($fp)                      # guardamos el puntero
\end_layout

\begin_layout Plain Layout
	sw a1, 44($fp)                      # guardamos el tamanio del bloque
\end_layout

\begin_layout Plain Layout
    sw a2, 48($fp)                      # guardamos el tamanio a agregar
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	addu a0, a1, a2						#a0 = nuevo tamanio bloque
\end_layout

\begin_layout Plain Layout
	la t9, mymalloc
\end_layout

\begin_layout Plain Layout
	jalr t9								#Llama a malloc
\end_layout

\begin_layout Plain Layout
	beq v0, zero, return				#Si devuelve cero ocurrio un error y devuelve cero
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw v0, 16($fp)						#Guardamos el puntero nuevo
\end_layout

\begin_layout Plain Layout
	addu s0, zero, zero					#s0 = indice actual
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
loop:
\end_layout

\begin_layout Plain Layout
	lw t0, 44($fp)						#t0 = tamanio original
\end_layout

\begin_layout Plain Layout
	bgeu s0, t0, terminar				#salta si ya copio todo
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw t0, 40 ($fp)						#t0 = puntero viejo
\end_layout

\begin_layout Plain Layout
	addu t0, t0, s0						#t0 = puntero viejo + indice
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw t1, 16($fp)						#t1 = puntero nuevo
\end_layout

\begin_layout Plain Layout
	addu t1, t1, s0						#t1 = puntero nuevo + indice
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lbu t2, 0(t0)						#Cargo el byte a copiar en t2
\end_layout

\begin_layout Plain Layout
	sb t2, 0(t1)						#Guardo el byte
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	addiu s0, s0, 1						#incremento el indice
\end_layout

\begin_layout Plain Layout
	b loop								#Vuelve al loop
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
terminar:
\end_layout

\begin_layout Plain Layout
	lw a0, 40($fp)						#a0 = puntero viejo
\end_layout

\begin_layout Plain Layout
	la t9, myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Libera el puntero viejo
\end_layout

\begin_layout Plain Layout
	lw v0, 16($fp)						#v0 = puntero nuevo
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
return:
\end_layout

\begin_layout Plain Layout
	lw s0, 24($fp)
\end_layout

\begin_layout Plain Layout
	lw ra, 36($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 32($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 28($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 40
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
.end myrealloc
\end_layout

\begin_layout Plain Layout
.size myrealloc,.-myrealloc 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Palindrome.S
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\small},breaklines=true,tabsize=4"
inline false
status open

\begin_layout Plain Layout
#include <mips/regdef.h>
\end_layout

\begin_layout Plain Layout
#include <sys/syscall.h>
\end_layout

\begin_layout Plain Layout
#define ASCII_A_MAY 65
\end_layout

\begin_layout Plain Layout
#define ASCII_Z_MAY 90
\end_layout

\begin_layout Plain Layout
#define ASCII_A_MIN 97
\end_layout

\begin_layout Plain Layout
#define ASCII_Z_MIN 122
\end_layout

\begin_layout Plain Layout
#define ASCII_CERO 48
\end_layout

\begin_layout Plain Layout
#define ASCII_NUEVE 57
\end_layout

\begin_layout Plain Layout
#define ASCII_GUION 45
\end_layout

\begin_layout Plain Layout
#define ASCII_GUIONBAJO 95
\end_layout

\begin_layout Plain Layout
#define ASCII_NEWLINE 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.text
\end_layout

\begin_layout Plain Layout
.abicalls
\end_layout

\begin_layout Plain Layout
.align 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.globl palindrome
\end_layout

\begin_layout Plain Layout
.ent palindrome
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
palindrome:							
\end_layout

\begin_layout Plain Layout
	.frame $fp, 48, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 48
\end_layout

\begin_layout Plain Layout
	sw $fp, 32(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 36
\end_layout

\begin_layout Plain Layout
	sw ra, 40(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 48($fp)                      # guardamos el archivo de entrada en
 el stackframe
\end_layout

\begin_layout Plain Layout
	sw a1, 52($fp)                      # guardamos el tamanio buffer entrada
\end_layout

\begin_layout Plain Layout
    sw a2, 56($fp)                      # guardamos el archivo de salida
 en el stackframe
\end_layout

\begin_layout Plain Layout
    sw a3, 60($fp)                      # guardamos el tamanio buffer salida
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    move a0, a1                         #a0 = tamanio del buffer entrada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    la t9, crear_buffer
\end_layout

\begin_layout Plain Layout
    jalr t9                           	#Crea el buffer de entrada
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_primer_buffer	#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout
    sw v0, 24($fp)                      #Guardamos el buffer de entrada
 en el stackframe
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw t1, 52($fp)
\end_layout

\begin_layout Plain Layout
    sw t1, 0(t0)						#Actualizo el tamanio del buffer entrada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    lw a0, 60($fp)                      #a0 = tamanio del buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, crear_buffer
\end_layout

\begin_layout Plain Layout
    jalr t9                           	#Crea el buffer de salida
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_segundo_buffer	#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout
    sw v0, 28($fp)                      #Guardamos el buffer de salida en
 el stackframe
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw t1, 60($fp)
\end_layout

\begin_layout Plain Layout
    sw t1, 0(t0)						#Actualizo el tamanio del buffer salida
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
loop_palindrome:
\end_layout

\begin_layout Plain Layout
    lw a0, 48($fp)                      #Cargamos en a0 el archivo de entrada
\end_layout

\begin_layout Plain Layout
	addu a1, $fp, 16                    #Cargamos en a1 el puntero a len
\end_layout

\begin_layout Plain Layout
    lw a2, 24($fp)                      #Cargamos en a2 el buffer de entrada
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	la t9, leer_palabra
\end_layout

\begin_layout Plain Layout
	jalr t9                          	#Lee la proxima palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sw v0, 20($fp)                      # Guardamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout
	beq v0, zero, error_palindrome      # No se pudo leer la palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	move a0, v0                         #a0 = puntero a palabra
\end_layout

\begin_layout Plain Layout
    lw a1, 16 ($fp)                     #a1 = len(palabra)
\end_layout

\begin_layout Plain Layout
	la t9, es_capicua
\end_layout

\begin_layout Plain Layout
	jalr t9                          	#Llama a es_capicua      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	beq v0, zero, continuar_loop_palindrome        #Si no es capicua continua
 el loop         
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw a0, 56($fp)                      #a0 = archivo de salida
\end_layout

\begin_layout Plain Layout
	lw a1, 20($fp)                      #a1 = puntero a la palabra
\end_layout

\begin_layout Plain Layout
    lw a2, 28($fp)                      #a2 = buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, putch
\end_layout

\begin_layout Plain Layout
    jalr t9                          	#Escribe la palabra en el archivo
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_escritura		#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
continuar_loop_palindrome:
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    lw a0, 20($fp)                      #a0 = puntero a palabra
\end_layout

\begin_layout Plain Layout
    la t9, myfree
\end_layout

\begin_layout Plain Layout
    jalr t9                           	#Llama a free(palabra)
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, eof_leido
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)						#t1 = eof leido?
\end_layout

\begin_layout Plain Layout
    beq t1, zero, loop_palindrome		#si no fue leido sigue el loop
\end_layout

\begin_layout Plain Layout
    la t0, eof_escrito
\end_layout

\begin_layout Plain Layout
    addiu t1, zero, 1
\end_layout

\begin_layout Plain Layout
    sw t1, 0(t0)						#actualizo eof_escrito = 1
\end_layout

\begin_layout Plain Layout
    lw a0, 56($fp)						#a0 = archivo de salida
\end_layout

\begin_layout Plain Layout
    lw a2, 28($fp)						#a2 = buffer de salida
\end_layout

\begin_layout Plain Layout
    la t9, putch
\end_layout

\begin_layout Plain Layout
    jalr t9                          	#Escribe todo lo que queda en el buffer
\end_layout

\begin_layout Plain Layout
    beq v0, zero, error_escritura		#Si devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
terminar_palindrome:
\end_layout

\begin_layout Plain Layout
	move v0, zero
\end_layout

\begin_layout Plain Layout
free_segundo_buffer:
\end_layout

\begin_layout Plain Layout
	lw a0, 28($fp)                      #Cargamos el buffer de salida 
\end_layout

\begin_layout Plain Layout
	la t9,myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Liberamos el segundo buffer
\end_layout

\begin_layout Plain Layout
free_primer_buffer:
\end_layout

\begin_layout Plain Layout
	lw a0, 24($fp)                      #Cargamos el buffer de entrada 
\end_layout

\begin_layout Plain Layout
	la t9,myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Liberamos el primer buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_palindrome:
\end_layout

\begin_layout Plain Layout
	lw ra, 40($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 36($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 32($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 48
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_segundo_buffer:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1					#Devuelve codigo de error 1
\end_layout

\begin_layout Plain Layout
	b free_primer_buffer				#Libera el primer buffer
\end_layout

\begin_layout Plain Layout
error_primer_buffer:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1 					#Devuelve codigo de error 1
\end_layout

\begin_layout Plain Layout
	b return_palindrome					#No libera nada
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_escritura:
\end_layout

\begin_layout Plain Layout
	lw a0, 20($fp)                      #a0 = puntero a la palabra
\end_layout

\begin_layout Plain Layout
	la t9, myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Libera la palabra
\end_layout

\begin_layout Plain Layout
error_palindrome:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 2 					#Devuelve codigo de error 2
\end_layout

\begin_layout Plain Layout
	b free_segundo_buffer				#Libera ambos buffer
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
.end palindrome
\end_layout

\begin_layout Plain Layout
.size palindrome,.-palindrome
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent es_capicua
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
es_capicua:
\end_layout

\begin_layout Plain Layout
	.frame $fp, 48, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 48
\end_layout

\begin_layout Plain Layout
    sw s0, 24(sp)
\end_layout

\begin_layout Plain Layout
    sw s1, 28(sp)
\end_layout

\begin_layout Plain Layout
	sw $fp, 32(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 36
\end_layout

\begin_layout Plain Layout
	sw ra, 40(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 48($fp)                  # Guardamos el puntero a la palabra (primer
 argumento) en el stackframe
\end_layout

\begin_layout Plain Layout
	sw a1, 52($fp)                  # Guardamos la longitud (segundo argumento)
 en el stackframe
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	beq a1, zero, return_false_capicua      #Si len es 0 devuelve false
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	addu s0, zero, zero             #Inicializamos la variable inicio
\end_layout

\begin_layout Plain Layout
	subu s1, a1, 1                  #Inicializamos la variable final
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
loop_capicua:
\end_layout

\begin_layout Plain Layout
	lw t0, 48($fp)          #Recuperamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout
    addu t0, t0, s0         #t0 = palabra + inicio
\end_layout

\begin_layout Plain Layout
	lbu a0, 0(t0)           # Leemos el  caracter palabra[inicio]
\end_layout

\begin_layout Plain Layout
	la t9, my_tolower       
\end_layout

\begin_layout Plain Layout
	jalr t9              	#Llamamos a tolower() con el caracter
\end_layout

\begin_layout Plain Layout
	sw v0, 16($fp)          # Guardamos el primer caracter en minuscula
\end_layout

\begin_layout Plain Layout
	lw a0, 48($fp)          #Recuperamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout
    addu t0, a0, s1         #t0 = palabra + final
\end_layout

\begin_layout Plain Layout
	lbu a0, 0(t0)	        # Leemos el  caracter palabra[final]
\end_layout

\begin_layout Plain Layout
	la t9, my_tolower
\end_layout

\begin_layout Plain Layout
	jalr t9              	#Llamamos a tolower() con el caracter
\end_layout

\begin_layout Plain Layout
	sw v0, 20($fp)          # Guardamos el segundo caracter en minuscula
\end_layout

\begin_layout Plain Layout
	move t0, v0             #t0 = segundo caracter
\end_layout

\begin_layout Plain Layout
	lw t1, 16($fp)          #t1 = primer caracter
\end_layout

\begin_layout Plain Layout
	bne t0, t1, return_false_capicua   #Si son distintos devuelve false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	addiu s0, s0, 1         #Suma uno (un byte) a inicio
\end_layout

\begin_layout Plain Layout
	subu s1, s1, 1          #Resta uno (un byte) a final
\end_layout

\begin_layout Plain Layout
	blt s0, s1, loop_capicua		#Si inicio < final vuelve al loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_true_capicua:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1
\end_layout

\begin_layout Plain Layout
	b return_capicua
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_false_capicua:
\end_layout

\begin_layout Plain Layout
	addu v0, zero, zero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_capicua:
\end_layout

\begin_layout Plain Layout
	lw ra, 40($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 36($fp)
\end_layout

\begin_layout Plain Layout
    lw s1, 28($fp)
\end_layout

\begin_layout Plain Layout
    lw s0, 24($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 32($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 48
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.end es_capicua
\end_layout

\begin_layout Plain Layout
.size es_capicua,.-es_capicua 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent my_tolower
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
my_tolower:
\end_layout

\begin_layout Plain Layout
	.frame $fp, 24, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 24
\end_layout

\begin_layout Plain Layout
	sw $fp, 16(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 20
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sw a0, 24($fp)              #Guardamos el primer argumento (caracter) en
 el stackframe
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	blt a0, ASCII_A_MAY, return_tolower     # Salta si caracter es menor a
 A
\end_layout

\begin_layout Plain Layout
	bgt a0, ASCII_Z_MAY, return_tolower     # Salta si caracter es mayor a
 Z
\end_layout

\begin_layout Plain Layout
	addiu a0, a0, 32            		# 32 es la diferencia entre minusculas y
 mayusculas en ascii
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
return_tolower:
\end_layout

\begin_layout Plain Layout
	move v0, a0                 #Pone el resultado en v0
\end_layout

\begin_layout Plain Layout
	lw gp, 20($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 16($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 24
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
.end my_tolower
\end_layout

\begin_layout Plain Layout
.size my_tolower,.-my_tolower 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent leer_palabra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
leer_palabra:
\end_layout

\begin_layout Plain Layout
	.frame $fp, 40, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 40
\end_layout

\begin_layout Plain Layout
    sw s0, 24(sp)
\end_layout

\begin_layout Plain Layout
	sw $fp, 28(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 32
\end_layout

\begin_layout Plain Layout
	sw ra, 36(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 40($fp)          # Guardamos el primer argumento en el stackframe
 (puntero al archivo)
\end_layout

\begin_layout Plain Layout
	sw a1, 44($fp)          # Guardamos el segundo argumento en el stackframe
 (puntero a longitud)
\end_layout

\begin_layout Plain Layout
    sw a2, 48($fp)          # Guardamos el tercer argumento en el stackframe
 (puntero a buffer)
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
    la t0, TAM
\end_layout

\begin_layout Plain Layout
	lw a0, 0(t0)            			#Carga TAM en a0     
\end_layout

\begin_layout Plain Layout
	la t9, mymalloc
\end_layout

\begin_layout Plain Layout
	jalr t9             				#Llama a malloc
\end_layout

\begin_layout Plain Layout
	beq v0, zero, terminar_con_error	#Si malloc devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sw v0, 16($fp)          			#Guardamos el puntero a la palabra en el stackframe
\end_layout

\begin_layout Plain Layout
	addu s0, zero, zero     			# Inicializamos la longitud de la palabra en
 cero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
loop_leer_palabra:
\end_layout

\begin_layout Plain Layout
	lw a0, 40($fp)                      # Recuperamos el puntero al archivo
\end_layout

\begin_layout Plain Layout
    lw a1, 48($fp)                      # Recuperamos el puntero al buffer
\end_layout

\begin_layout Plain Layout
	la t9, getch
\end_layout

\begin_layout Plain Layout
	jalr t9                          	#Leemos un caracter, queda en v0
\end_layout

\begin_layout Plain Layout
	beq v0, -1, error_leer_palabra		#Si devuelve -1 ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	beq v0, ASCII_GUION, es_caracter    # Salta si es -
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	beq v0, ASCII_GUIONBAJO, es_caracter   # Salta si es _
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sgeu t0, v0, ASCII_A_MAY            # Mayor que "A"
\end_layout

\begin_layout Plain Layout
	sleu t1, v0, ASCII_Z_MAY            # Menor que "Z"
\end_layout

\begin_layout Plain Layout
	beq t0, t1, es_caracter             # Salta si es letra mayuscula
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sgeu t0, v0, ASCII_A_MIN            # Mayor que "a"
\end_layout

\begin_layout Plain Layout
	sleu t1, v0, ASCII_Z_MIN            # Menor que "z"
\end_layout

\begin_layout Plain Layout
	beq t0, t1, es_caracter             # Salta si es letra minuscula
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	sgeu t0, v0, ASCII_CERO             # Mayor que "0"
\end_layout

\begin_layout Plain Layout
	sleu t1, v0, ASCII_NUEVE            # Menor que "9"
\end_layout

\begin_layout Plain Layout
	beq t0, t1, es_caracter             #Salta si es un numero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
no_es_caracter:
\end_layout

\begin_layout Plain Layout
	lw a0, 16($fp)                      # Recuperamos puntero a palabra
\end_layout

\begin_layout Plain Layout
	addu t0, s0, a0                     #t0 = palabra + len
\end_layout

\begin_layout Plain Layout
	addiu t1, zero, ASCII_NEWLINE
\end_layout

\begin_layout Plain Layout
	sb t1, 0(t0)                      	#Guardamos el "
\backslash
n"
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw a1, 44($fp)	                    # Cargamos puntero a len
\end_layout

\begin_layout Plain Layout
	sw s0, 0(a1)                        # Guardamos el len
\end_layout

\begin_layout Plain Layout
	b terminar_leer_palabra             #Sale del loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
es_caracter:
\end_layout

\begin_layout Plain Layout
	lw a0, 16($fp)                      # Recuperamos puntero a palabra
\end_layout

\begin_layout Plain Layout
	addu t0, s0, a0                     #t0 = palabra + len
\end_layout

\begin_layout Plain Layout
	sb v0, 0(t0)                        #Guardamos el caracter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	addiu s0, s0, 1                     #Incrementamos len
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	la t0, TAM
\end_layout

\begin_layout Plain Layout
	lw t1, 0(t0)                        #Carga TAM en t1  
\end_layout

\begin_layout Plain Layout
	remu t2, s0, t1                     #t2 = len % tam
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	bne t2, zero, loop_leer_palabra     #Continua al loop si el modulo no es
 0
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	lw a0, 16($fp)                      # Recuperamos puntero a palabra en
 a0
\end_layout

\begin_layout Plain Layout
	move a1, s0							#a1 = len
\end_layout

\begin_layout Plain Layout
	la t0, TAM
\end_layout

\begin_layout Plain Layout
	lw a2, 0(t0)            			#Carga TAM en a2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	la t9, myrealloc
\end_layout

\begin_layout Plain Layout
	jalr t9                          	#Llama a realloc
\end_layout

\begin_layout Plain Layout
	beq v0, zero, error_leer_palabra	#Si realloc devuelve 0 ocurrio un error
\end_layout

\begin_layout Plain Layout
	sw v0, 16($fp)          			#Guardamos el nuevo puntero en el stackframe
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	b loop_leer_palabra                 #Vuelve siempre al loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
terminar_leer_palabra:
\end_layout

\begin_layout Plain Layout
	lw v0, 16($fp)                      #Carga en v0 el puntero a la palabra
\end_layout

\begin_layout Plain Layout
return_leer_palabra:
\end_layout

\begin_layout Plain Layout
    lw s0, 24($fp)
\end_layout

\begin_layout Plain Layout
	lw ra, 36($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 32($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 28($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 40
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_leer_palabra:
\end_layout

\begin_layout Plain Layout
	lw a0, 16($fp)                      # Recuperamos puntero a palabra en
 a0
\end_layout

\begin_layout Plain Layout
	la t9, myfree
\end_layout

\begin_layout Plain Layout
	jalr t9								#Llama a free con la palabra
\end_layout

\begin_layout Plain Layout
terminar_con_error:
\end_layout

\begin_layout Plain Layout
	move v0, zero						#Devuelve 0 si ocurrio un error
\end_layout

\begin_layout Plain Layout
	b return_leer_palabra						
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
.end leer_palabra
\end_layout

\begin_layout Plain Layout
.size leer_palabra,.-leer_palabra  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent crear_buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
crear_buffer:
\end_layout

\begin_layout Plain Layout
	.frame $fp, 32, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 32
\end_layout

\begin_layout Plain Layout
	sw $fp, 16(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 20
\end_layout

\begin_layout Plain Layout
	sw ra, 24(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 32($fp)                      # Guardamos el tamanio del buffer en
 el stackframe
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    la t9, mymalloc                    
\end_layout

\begin_layout Plain Layout
    jalr t9                          	#Llama a malloc
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    bne v0, zero, return_crear_buffer   #Salta si no ocurrio un error
\end_layout

\begin_layout Plain Layout
    move v0, zero						#Devuelve 0 si ocurrio un error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_crear_buffer:
\end_layout

\begin_layout Plain Layout
    lw ra, 24($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 20($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 16($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 32
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.end crear_buffer
\end_layout

\begin_layout Plain Layout
.size crear_buffer,.-crear_buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent getch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
getch:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	.frame $fp, 40, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 40
\end_layout

\begin_layout Plain Layout
	sw s0, 16(sp)
\end_layout

\begin_layout Plain Layout
	sw s1, 20(sp)
\end_layout

\begin_layout Plain Layout
	sw $fp, 24(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 28
\end_layout

\begin_layout Plain Layout
	sw ra, 32(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 40($fp)                      # Guardamos el archivo de entrada en
 el stackframe
\end_layout

\begin_layout Plain Layout
	sw a1, 44($fp)                      # Guardamos el puntero al buffer en
 el stackframe
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
    la t0, pos_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw s0, 0(t0)                      #s0 = pos actual del buffer
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw a2, 0(t0)                      #a2 = tam actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    bltu s0, a2, leer_caracter          #Salta si pos actual < tam buffer
       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Si no salta tengo que volver a leer del archivo y llenar el buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    li v0, SYS_read
\end_layout

\begin_layout Plain Layout
    syscall
\end_layout

\begin_layout Plain Layout
    bne a3, zero, error_getch			#Salta si hubo un error
\end_layout

\begin_layout Plain Layout
    beq v0, zero, leyo_eof_getch		#Si read devuelve 0 leyo EOF
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    addu s0, zero, zero                 #Pos_actual = 0
\end_layout

\begin_layout Plain Layout
    move s1,v0 							#s1 = cantidad bytes leidos
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw a2, 0(t0)                      	#a2 = tam actual del buffer
\end_layout

\begin_layout Plain Layout
    beq v0,a2, leer_caracter			#Salta si read no leyo menos bytes de lo
 indicado
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
#Si leyo menos bytes 
\end_layout

\begin_layout Plain Layout
leer_archivo:
\end_layout

\begin_layout Plain Layout
	lw a0, 40($fp)                      # a0 = archivo de entrada
\end_layout

\begin_layout Plain Layout
	lw a1, 44($fp)                      
\end_layout

\begin_layout Plain Layout
	addu a1, a1, s1						#a1 = puntero a buffer + cant bytes leidos
\end_layout

\begin_layout Plain Layout
	la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw a2, 0(t0)                      
\end_layout

\begin_layout Plain Layout
	subu a2, a2, s1						#a2 = tam actual del buffer - cant bytes leidos
\end_layout

\begin_layout Plain Layout
	li v0, SYS_read
\end_layout

\begin_layout Plain Layout
	syscall
\end_layout

\begin_layout Plain Layout
	bne a3, zero, error_getch			#Salta si hubo un error
\end_layout

\begin_layout Plain Layout
	beq v0, zero, eof_leido_getch		#Si es cero leyo eof
\end_layout

\begin_layout Plain Layout
	addu s1, s1, v0						#s1 = cant bytes leidos
\end_layout

\begin_layout Plain Layout
	la t0, tam_buffer_entrada
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)						#t1 = tam buffer entrada
\end_layout

\begin_layout Plain Layout
    blt s1, t1, leer_archivo			#Si cant bytes leidos < tam vuelve a leer
\end_layout

\begin_layout Plain Layout
    beq s1, t1, leer_caracter			#Si ya leyo todo salta a leer caracter
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
eof_leido_getch:
\end_layout

\begin_layout Plain Layout
	la t0, tam_buffer_entrada			#Si leyo menos bytes pero todavia hay cosas
 en el buffer
\end_layout

\begin_layout Plain Layout
	sw s1, 0(t0)						#Actualizo el tamanio del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
leer_caracter:
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    lw a1, 44($fp)                      #Cargo el puntero al buffer
\end_layout

\begin_layout Plain Layout
    addu t2, s0, a1                     #t2 = buffer + pos
\end_layout

\begin_layout Plain Layout
    lbu v0, 0(t2)                       #v0 = caracter leido
\end_layout

\begin_layout Plain Layout
    addiu s0, s0, 1                     #Incremento la posicion actual
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    la t0, pos_buffer_entrada
\end_layout

\begin_layout Plain Layout
    sw s0, 0(t0)                      #Guardamos la pos actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
return_getch:
\end_layout

\begin_layout Plain Layout
	lw s0, 16($fp)
\end_layout

\begin_layout Plain Layout
	lw s1, 20($fp)
\end_layout

\begin_layout Plain Layout
    lw ra, 32($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 28($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 24($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 40
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
leyo_eof_getch:
\end_layout

\begin_layout Plain Layout
	la t0, eof_leido
\end_layout

\begin_layout Plain Layout
	addiu t1,zero,1
\end_layout

\begin_layout Plain Layout
	sw t1, 0(t0)						#Actualizo la variable EOF leido
\end_layout

\begin_layout Plain Layout
	addu v0, zero, zero					#Devuelvo 0
\end_layout

\begin_layout Plain Layout
	b return_getch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_getch:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, -1					#Devuelvo -1 
\end_layout

\begin_layout Plain Layout
	b return_getch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.end getch
\end_layout

\begin_layout Plain Layout
.size getch,.-getch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#_______________________________________________________________________________
____________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.ent putch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
putch:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	.frame $fp, 48, ra
\end_layout

\begin_layout Plain Layout
	.set noreorder
\end_layout

\begin_layout Plain Layout
	.cpload t9
\end_layout

\begin_layout Plain Layout
	.set reorder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	subu sp, sp, 48
\end_layout

\begin_layout Plain Layout
	sw s0, 16(sp)
\end_layout

\begin_layout Plain Layout
	sw s1, 20(sp)
\end_layout

\begin_layout Plain Layout
	sw s2, 24(sp)
\end_layout

\begin_layout Plain Layout
	sw s3, 28(sp)
\end_layout

\begin_layout Plain Layout
	sw $fp, 32(sp)
\end_layout

\begin_layout Plain Layout
	.cprestore 36
\end_layout

\begin_layout Plain Layout
	sw ra, 40(sp)
\end_layout

\begin_layout Plain Layout
	move $fp, sp
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	sw a0, 48($fp)                      # Guardamos el archivo de salida en
 el stackframe
\end_layout

\begin_layout Plain Layout
	sw a1, 52($fp)                      # Guardamos el puntero a la palabra
 en el stackframe
\end_layout

\begin_layout Plain Layout
    sw a2, 56($fp)                      # Guardamos el buffer en el stackframe
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    la t0, pos_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw s0, 0(t0)                      #s0 = pos actual del buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    addu s1, zero, zero                 #Inicializamos el indice de la palabra
 en s1
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, eof_escrito
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)                      #t1 = eof debe ser escrito?
\end_layout

\begin_layout Plain Layout
    beq t1,zero, loop_putch				#Salta si eof no debe ser escrito
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    move s3, zero						#s3 = cant bytes escritos = 0
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    sw s0, 0(t0)                      #Actualiza el tamanio del buffer a
 la posicion actual
\end_layout

\begin_layout Plain Layout
    b escribir_todo_putch
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
loop_putch:
\end_layout

\begin_layout Plain Layout
    lw a1, 52($fp)                      #Cargamos el puntero a la palabra
\end_layout

\begin_layout Plain Layout
    addu t3, a1, s1                     #t3 = palabra + indice
\end_layout

\begin_layout Plain Layout
    lbu s2, 0(t3)                       #s2 = caracter a escribir
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    lw a2, 56($fp)                      #Cargamos el puntero al buffer
\end_layout

\begin_layout Plain Layout
    addu t5, a2, s0                     #t5 = buffer + pos_actual
\end_layout

\begin_layout Plain Layout
    sb s2, 0(t5)                        #Guardamos el caracter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
    addiu s0,s0,1                       #Incrementamos pos_actual
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)                      	#Cargamos el tamanio del buffer
\end_layout

\begin_layout Plain Layout
    bltu s0, t1, continuar_loop_putch   #Salta si pos_actual < tam_buffer
\end_layout

\begin_layout Plain Layout
    move s3, zero						#s3 = cant bytes escritos = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#Si no salta tengo que volver a escribir el archivo y vaciar el buffer
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
escribir_todo_putch:
\end_layout

\begin_layout Plain Layout
    lw a0, 48($fp)                      # Cargamos el archivo de salida
 
\end_layout

\begin_layout Plain Layout
    lw a1, 56($fp)                      # Cargamos el buffer 
\end_layout

\begin_layout Plain Layout
    addu a1, a1, s3						#a1 = buffer + cant bytes escritos
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw a2, 0(t0)                        # Cargamos el tamanio total del
 buffer 
\end_layout

\begin_layout Plain Layout
    subu a2, a2, s3						#a2 = tam - cant bytes escritos
\end_layout

\begin_layout Plain Layout
    li v0, SYS_write
\end_layout

\begin_layout Plain Layout
    syscall
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    bne a3, zero, error_putch			#Salta si ocurrio un error
\end_layout

\begin_layout Plain Layout
    addu s3, s3, v0						#s3 = cant bytes escritos
\end_layout

\begin_layout Plain Layout
    la t0, tam_buffer_salida
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)                        # t1 = tamanio total del buffer
 
\end_layout

\begin_layout Plain Layout
    blt s3, t1, escribir_todo_putch		#Si escribio menos bytes vuelve a escribir
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    addu s0, zero, zero                 #Pos_actual = 0
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
    la t0, eof_escrito
\end_layout

\begin_layout Plain Layout
    lw t1, 0(t0)                      #t1 = eof_escrito
\end_layout

\begin_layout Plain Layout
    bgt t1, zero, terminar_putch		#Termina si EOF fue escrito
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
continuar_loop_putch:
\end_layout

\begin_layout Plain Layout
    addu s1, s1, 1                      		#Incrementamos el indice de la
 palabra
\end_layout

\begin_layout Plain Layout
    beq s2, ASCII_NEWLINE, terminar_putch    	#Termina si es 
\backslash
n
\end_layout

\begin_layout Plain Layout
    b loop_putch                        		#Vuelve al loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
terminar_putch:
\end_layout

\begin_layout Plain Layout
	addiu v0, zero, 1					#Devuelve 1 si no ocurrio un error
\end_layout

\begin_layout Plain Layout
return_putch:
\end_layout

\begin_layout Plain Layout
    la t0, pos_buffer_salida
\end_layout

\begin_layout Plain Layout
    sw s0, 0(t0)                      
\end_layout

\begin_layout Plain Layout
    lw s0, 16($fp)
\end_layout

\begin_layout Plain Layout
    lw s1, 20($fp)
\end_layout

\begin_layout Plain Layout
    lw s2, 24($fp)
\end_layout

\begin_layout Plain Layout
    lw s3, 28($fp)
\end_layout

\begin_layout Plain Layout
    lw ra, 40($fp)
\end_layout

\begin_layout Plain Layout
	lw gp, 36($fp)
\end_layout

\begin_layout Plain Layout
	lw $fp, 32($fp)
\end_layout

\begin_layout Plain Layout
	addiu sp, sp, 48
\end_layout

\begin_layout Plain Layout
	jr ra
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
error_putch:
\end_layout

\begin_layout Plain Layout
	move v0, zero						#Devuelve 0 si ocurrio un error
\end_layout

\begin_layout Plain Layout
	b return_putch
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.end putch
\end_layout

\begin_layout Plain Layout
.size putch,.-putch
\end_layout

\begin_layout Plain Layout
    
\end_layout

\begin_layout Plain Layout
#__________________________________________________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
.data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
pos_buffer_entrada: .word -1
\end_layout

\begin_layout Plain Layout
tam_buffer_entrada: .word 0
\end_layout

\begin_layout Plain Layout
pos_buffer_salida: .word 0
\end_layout

\begin_layout Plain Layout
tam_buffer_salida: .word 0
\end_layout

\begin_layout Plain Layout
eof_leido: .word 0
\end_layout

\begin_layout Plain Layout
eof_escrito: .word 0
\end_layout

\begin_layout Plain Layout
TAM: .word 50
\end_layout

\end_inset


\end_layout

\end_body
\end_document
